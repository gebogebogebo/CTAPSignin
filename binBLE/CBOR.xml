<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CBOR</name>
    </assembly>
    <members>
        <member name="T:PeterO.Cbor.CBORNumber">
            <summary>An instance of a number that CBOR or certain CBOR tags can
            represent. For this purpose, infinities and not-a-number or NaN
            values are considered numbers. Currently, this class can store one
            of the following kinds of numbers: 64-bit signed integers or binary
            floating-point numbers; or arbitrary-precision integers, decimal
            numbers, binary numbers, or rational numbers.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORNumber.Kind.Integer">
            <summary>A 64-bit signed integer.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORNumber.Kind.Double">
            <summary>A 64-bit binary floating-point number.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORNumber.Kind.EInteger">
            <summary>An arbitrary-precision integer.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORNumber.Kind.EDecimal">
            <summary>An arbitrary-precision decimal number.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORNumber.Kind.EFloat">
            <summary>An arbitrary-precision binary number.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORNumber.Kind.ERational">
            <summary>An arbitrary-precision rational number.</summary>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.ToCBORObject">
            <summary>Converts this object's value to a CBOR object.</summary>
            <returns>A CBOR object that stores this object's value.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.FromCBORObject(PeterO.Cbor.CBORObject)">
            <summary>Creates a CBOR number object from a CBOR object
            representing a number (that is, one for which the IsNumber property
            in.NET or the isNumber() method in Java returns true).</summary>
            <param name='o'>The parameter is a CBOR object representing a
            number.</param>
            <returns>A CBOR number object, or null if the given CBOR object is
            null or does not represent a number.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.ToString">
            <summary>Returns the value of this object in text form.</summary>
            <returns>A text string representing the value of this
            object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.Negate">
            <summary>Returns a CBOR number with the same value as this one but
            with the sign reversed.</summary>
            <returns>A CBOR number with the same value as this one but with the
            sign reversed.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.Add(PeterO.Cbor.CBORNumber)">
            <summary>Returns the sum of this number and another
            number.</summary>
            <param name='b'>The number to add with this one.</param>
            <returns>The sum of this number and another number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='b'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.Subtract(PeterO.Cbor.CBORNumber)">
            <summary>Returns a number that expresses this number minus
            another.</summary>
            <param name='b'>The second operand to the subtraction.</param>
            <returns>A CBOR number that expresses this number minus the given
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='b'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.Multiply(PeterO.Cbor.CBORNumber)">
            <summary>Returns a CBOR number expressing the product of this
            number and the given number.</summary>
            <param name='b'>The second operand to the multiplication
            operation.</param>
            <returns>A number expressing the product of this number and the
            given number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='b'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.Divide(PeterO.Cbor.CBORNumber)">
            <summary>Returns the quotient of this number and another
            number.</summary>
            <param name='b'>The right-hand side (divisor) to the division
            operation.</param>
            <returns>The quotient of this number and another one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='b'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.Remainder(PeterO.Cbor.CBORNumber)">
            <summary>Returns the remainder when this number is divided by
            another number.</summary>
            <param name='b'>The right-hand side (dividend) of the remainder
            operation.</param>
            <returns>The remainder when this number is divided by the other
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='b'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.CompareTo(PeterO.Cbor.CBORNumber)">
            <summary>Compares two CBOR numbers. In this implementation, the two
            numbers' mathematical values are compared. Here, NaN (not-a-number)
            is considered greater than any number.</summary>
            <param name='other'>A value to compare with. Can be null.</param>
            <returns>A negative number, if this value is less than the other
            object; or 0, if both values are equal; or a positive number, if
            this value is less than the other object or if the other object is
            null.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.op_LessThan(PeterO.Cbor.CBORNumber,PeterO.Cbor.CBORNumber)">
            <summary>Returns whether one object's value is less than
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if the first object's value is less than the
            other's; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.op_LessThanOrEqual(PeterO.Cbor.CBORNumber,PeterO.Cbor.CBORNumber)">
            <summary>Returns whether one object's value is up to
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is up to another's;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.op_GreaterThan(PeterO.Cbor.CBORNumber,PeterO.Cbor.CBORNumber)">
            <summary>Returns whether one object's value is greater than
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is greater than
            another's; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORNumber.op_GreaterThanOrEqual(PeterO.Cbor.CBORNumber,PeterO.Cbor.CBORNumber)">
            <summary>Returns whether one object's value is at least
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is at least another's;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> is null.</exception>
        </member>
        <member name="F:PeterO.Cbor.URIUtility.ParseMode.IRIStrict">
            <summary>The rules follow the syntax for parsing IRIs. In
            particular, many code points outside the Basic Latin range (U+0000
            to U+007F) are allowed. Strings with unpaired surrogate code points
            are considered invalid.</summary>
        </member>
        <member name="F:PeterO.Cbor.URIUtility.ParseMode.URIStrict">
            <summary>The rules follow the syntax for parsing IRIs, except that
            code points outside the Basic Latin range (U+0000 to U+007F) are
            not allowed.</summary>
        </member>
        <member name="F:PeterO.Cbor.URIUtility.ParseMode.IRILenient">
            <summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Even with this mode, strings with unpaired
            surrogate code points are considered invalid.</summary>
        </member>
        <member name="F:PeterO.Cbor.URIUtility.ParseMode.URILenient">
            <summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Code points outside the Basic Latin range
            (U+0000 to U+007F) are not allowed.</summary>
        </member>
        <member name="F:PeterO.Cbor.URIUtility.ParseMode.IRISurrogateLenient">
            <summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Unpaired surrogate code points are treated as
            though they were replacement characters instead for the purposes of
            these rules, so that strings with those code points are not
            considered invalid strings.</summary>
        </member>
        <member name="T:PeterO.Cbor.CBOREncodeOptions">
            <summary>Specifies options for encoding and decoding CBOR
            objects.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBOREncodeOptions.Default">
            <summary>Default options for CBOR objects. Disallow duplicate keys,
            and always encode strings using definite-length encoding.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBOREncodeOptions.DefaultCtap2Canonical">
            <summary>Default options for CBOR objects serialized using the
            CTAP2 canonicalization (used in Web Authentication, among other
            specifications). Disallow duplicate keys, and always encode strings
            using definite-length encoding.</summary>
        </member>
        <member name="M:PeterO.Cbor.CBOREncodeOptions.#ctor">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.CBOREncodeOptions'/> class.</summary>
        </member>
        <member name="M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.Boolean,System.Boolean)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.CBOREncodeOptions'/> class.</summary>
            <param name='useIndefLengthStrings'>A value indicating whether to
            always encode strings with a definite-length encoding.</param>
            <param name='allowDuplicateKeys'>A value indicating whether to
            disallow duplicate keys when reading CBOR objects from a data
            stream.</param>
        </member>
        <member name="M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.CBOREncodeOptions'/> class.</summary>
            <param name='useIndefLengthStrings'>A value indicating whether to
            encode strings with a definite-length encoding in certain
            cases.</param>
            <param name='allowDuplicateKeys'>A value indicating whether to
            allow duplicate keys when reading CBOR objects from a data
            stream.</param>
            <param name='ctap2Canonical'>A value indicating whether CBOR
            objects are written out using the CTAP2 canonical CBOR encoding
            form, which is useful for implementing Web Authentication.</param>
        </member>
        <member name="M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.String)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.CBOREncodeOptions'/> class.</summary>
            <param name='paramString'>A string setting forth the options to
            use. This is a semicolon-separated list of options, each of which
            has a key and a value separated by an equal sign ("="). Whitespace
            and line separators are not allowed to appear between the
            semicolons or between the equal signs, nor may the string begin or
            end with whitespace. The string can be empty, but cannot be null.
            The following is an example of this parameter:
            <c>allowduplicatekeys=true;ctap2Canonical=true</c>. The key can be
            any one of the following in any combination of case:
            <c>allowduplicatekeys</c>, <c>ctap2canonical</c>,
            <c>resolvereferences</c>, <c>useindeflengthstrings</c>,
            <c>allowempty</c>. Keys other than these are ignored. (Keys are
            compared using a basic case-insensitive comparison, in which two
            strings are equal if they match after converting the basic
            upper-case letters A to Z (U+0041 to U+005A) in both strings to
            basic lower-case letters.) If two or more key/value pairs have
            equal keys (in a basic case-insensitive comparison), the value
            given for the last such key is used. The four keys just given can
            have a value of <c>1</c>, <c>true</c>, <c>yes</c>, or <c>on</c>
            (in any combination of case), which means true, and any other value
            meaning false. For example, <c>allowduplicatekeys=Yes</c> and
            <c>allowduplicatekeys=1</c> both set the <c>AllowDuplicateKeys</c>
            property to true. In the future, this class may allow other keys to
            store other kinds of values, not just true or false.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='paramString'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBOREncodeOptions.ToString">
            <summary>Gets the values of this options object's properties in
            text form.</summary>
            <returns>A text string containing the values of this options
            object's properties. The format of the string is the same as the
            one described in the String constructor for this class.</returns>
        </member>
        <member name="P:PeterO.Cbor.CBOREncodeOptions.ResolveReferences">
            <summary>Gets a value indicating whether to resolve references to
            sharable objects and sharable strings in the process of decoding a
            CBOR object. Enabling this property, however, can cause a security
            risk if a decoded CBOR object is then re-encoded.</summary>
            <value>A value indicating whether to resolve references to sharable
            objects and sharable strings. The default is false.</value>
            <remarks>
            <para><b>About sharable objects and references</b></para>
            <para>Sharable objects are marked with tag 28, and references to
            those objects are marked with tag 29 (where a reference of 0 means
            the first sharable object in the CBOR stream, a reference of 1
            means the second, and so on). Sharable strings (byte strings and
            text strings) appear within an enclosing object marked with tag
            256, and references to them are marked with tag 25; in general, a
            string is sharable only if storing its reference rather than the
            string would save space.</para>
            <para>Note that unlike most other tags, these tags generally care
            about the relative order in which objects appear in a CBOR stream;
            thus they are not interoperable with CBOR implementations that
            follow the generic CBOR data model (since they may list map keys in
            an unspecified order). Interoperability problems with these tags
            can be reduced by not using them to mark keys or values of a map or
            to mark objects within those keys or values.</para>
            <para><b>Security Note</b></para>
            <para>When this property is enabled and a decoded CBOR object
            contains references to sharable CBOR objects within it, those
            references will be replaced with the sharable objects they refer to
            (but without making a copy of those objects). However, if shared
            references are deeply nested and used multiple times, these
            references can result in a CBOR object that is orders of magnitude
            bigger than if shared references weren't resolved, and this can
            cause a denial of service when the decoded CBOR object is then
            serialized (e.g., with <c>EncodeToBytes()</c>, <c>ToString()</c>,
            <c>ToJSONString()</c>, or <c>WriteTo</c> ), because object
            references are expanded in the process.</para>
            <para>For example, the following object in CBOR diagnostic
            notation, <c>[28(["xxx", "yyy"]), 28([29(0), 29(0), 29(0)]),
            28([29(1), 29(1)]), 28([29(2), 29(2)]), 28([29(3), 29(3)]),
            28([29(4), 29(4)]), 28([29(5), 29(5)])]</c>, expands to a CBOR
            object with a serialized size of about 1831 bytes when this
            property is enabled, as opposed to about 69 bytes when this
            property is disabled.</para>
            <para>One way to mitigate security issues with this property is to
            limit the maximum supported size a CBORObject can have once
            serialized to CBOR or JSON. This can be done by passing a so-called
            "limited memory stream" to the <c>WriteTo</c> or <c>WriteJSONTo</c>
            methods when serializing the object to JSON or CBOR. A "limited
            memory stream" is a <c>Stream</c> (or <c>OutputStream</c> in Java)
            that throws an exception if it would write more bytes than a given
            maximum size or would seek past that size. (See the documentation
            for <c>CBORObject.WriteTo</c> or <c>CBORObject.WriteJSONTo</c> for
            example code.) Another mitigation is to check the CBOR object's
            type before serializing it, since only arrays and maps can have the
            security problem described here, or to check the maximum nesting
            depth of a CBOR array or map before serializing
            it.</para></remarks>
        </member>
        <member name="P:PeterO.Cbor.CBOREncodeOptions.UseIndefLengthStrings">
            <summary>Gets a value indicating whether to encode strings with an
            indefinite-length encoding under certain circumstances.</summary>
            <value>A value indicating whether to encode strings with an
            indefinite-length encoding under certain circumstances. The default
            is false.</value>
        </member>
        <member name="P:PeterO.Cbor.CBOREncodeOptions.AllowEmpty">
            <summary>Gets a value indicating whether decoding a CBOR object
            will return <c>null</c> instead of a CBOR object if the stream has
            no content or the end of the stream is reached before decoding
            begins. Used only when decoding CBOR objects.</summary>
            <value>A value indicating whether decoding a CBOR object will
            return <c>null</c> instead of a CBOR object if the stream has no
            content or the end of the stream is reached before decoding begins.
            The default is false.</value>
        </member>
        <member name="P:PeterO.Cbor.CBOREncodeOptions.AllowDuplicateKeys">
            <summary>Gets a value indicating whether to allow duplicate keys
            when reading CBOR objects from a data stream. Used only when
            decoding CBOR objects.</summary>
            <value>A value indicating whether to allow duplicate keys when
            reading CBOR objects from a data stream. The default is
            false.</value>
        </member>
        <member name="P:PeterO.Cbor.CBOREncodeOptions.Ctap2Canonical">
            <summary>Gets a value indicating whether CBOR objects:
            <list>
            <item>When encoding, are written out using the CTAP2 canonical CBOR
            encoding form, which is useful for implementing Web
            Authentication.</item>
            <item>When decoding, are checked for compliance with the CTAP2
            canonical encoding form.</item></list> In this form, CBOR tags are
            not used, map keys are written out in a canonical order, a maximum
            depth of four levels of arrays and/or maps is allowed, duplicate
            map keys are not allowed when decoding, and floating-point numbers
            are written out in their 64-bit encoding form regardless of whether
            their value can be encoded without loss in a smaller form. This
            implementation allows CBOR objects whose canonical form exceeds
            1024 bytes, the default maximum size for CBOR objects in that form
            according to the FIDO Client-to-Authenticator Protocol 2
            specification.</summary>
            <value><c>true</c> if CBOR objects are written out using the CTAP2
            canonical CBOR encoding form; otherwise, <c>false</c>. The default
            is <c>false</c>.</value>
        </member>
        <member name="T:PeterO.Cbor.ICBORConverter`1">
            <summary>Interface implemented by classes that convert objects of
            arbitrary types to CBOR objects.</summary>
            <typeparam name='T'>Type to convert to a CBOR object.</typeparam>
        </member>
        <member name="M:PeterO.Cbor.ICBORConverter`1.ToCBORObject(`0)">
            <summary>Converts an object to a CBOR object.</summary>
            <param name='obj'>An object to convert to a CBOR object.</param>
            <returns>A CBOR object.</returns>
        </member>
        <member name="T:PeterO.Cbor.ICharacterInput">
            <summary>An interface for reading Unicode characters from a data
            source.</summary>
        </member>
        <member name="M:PeterO.Cbor.ICharacterInput.ReadChar">
            <summary>Reads a Unicode character from a data source.</summary>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>
        </member>
        <member name="M:PeterO.Cbor.ICharacterInput.Read(System.Int32[],System.Int32,System.Int32)">
            <summary>Reads a sequence of Unicode code points from a data
            source.</summary>
            <param name='chars'>Output buffer.</param>
            <param name='index'>Index in the output buffer to start writing
            to.</param>
            <param name='length'>Maximum number of code points to
            write.</param>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>
            <exception cref='T:System.ArgumentException'>Either &#x22;index&#x22; or
            &#x22;length&#x22; is less than 0 or greater than
            &#x22;chars&#x22;&#x27;s length, or &#x22;chars&#x22;&#x27;s length
            minus &#x22;index&#x22; is less than
            &#x22;length&#x22;.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
        </member>
        <member name="T:PeterO.Cbor.CBORUtilities">
            <summary>Contains utility methods that may have use outside of the
            CBORObject class.</summary>
        </member>
        <member name="T:PeterO.Cbor.JSONOptions">
            <summary>Includes options to control how CBOR objects are converted
            to JSON.</summary>
        </member>
        <member name="M:PeterO.Cbor.JSONOptions.#ctor">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.JSONOptions'/> class with default
            options.</summary>
        </member>
        <member name="M:PeterO.Cbor.JSONOptions.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.JSONOptions'/> class with the given value
            for the Base64Padding option.</summary>
            <param name='base64Padding'>Whether padding is included when
            writing data in base64url or traditional base64 format to
            JSON.</param>
        </member>
        <member name="M:PeterO.Cbor.JSONOptions.#ctor(System.Boolean,System.Boolean)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.JSONOptions'/> class with the given values
            for the options.</summary>
            <param name='base64Padding'>Whether padding is included when
            writing data in base64url or traditional base64 format to
            JSON.</param>
            <param name='replaceSurrogates'>Whether surrogate code points not
            part of a surrogate pair (which consists of two consecutive
            <c>char</c> s forming one Unicode code point) are each replaced
            with a replacement character (U+FFFD). The default is false; an
            exception is thrown when such code points are encountered.</param>
        </member>
        <member name="M:PeterO.Cbor.JSONOptions.#ctor(System.String)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.JSONOptions'/> class.</summary>
            <param name='paramString'>A string setting forth the options to
            use. This is a semicolon-separated list of options, each of which
            has a key and a value separated by an equal sign ("="). Whitespace
            and line separators are not allowed to appear between the
            semicolons or between the equal signs, nor may the string begin or
            end with whitespace. The string can be empty, but cannot be null.
            The following is an example of this parameter:
            <c>base64padding=false;replacesurrogates=true</c>. The key can be
            any one of the following in any combination of case:
            <c>base64padding</c>, <c>replacesurrogates</c>. Other keys are
            ignored. (Keys are compared using a basic case-insensitive
            comparison, in which two strings are equal if they match after
            converting the basic upper-case letters A to Z (U+0041 to U+005A)
            in both strings to basic lower-case letters.) If two or more
            key/value pairs have equal keys (in a basic case-insensitive
            comparison), the value given for the last such key is used. The two
            keys just given can have a value of <c>1</c>, <c>true</c>,
            <c>yes</c>, or <c>on</c> (in any combination of case), which means
            true, and any other value meaning false. For example,
            <c>base64padding=Yes</c> and <c>base64padding=1</c> both set the
            <c>Base64Padding</c> property to true.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='paramString'/> is null. In the future, this class may allow
            other keys to store other kinds of values, not just true or
            false.</exception>
        </member>
        <member name="M:PeterO.Cbor.JSONOptions.ToString">
            <summary>Gets the values of this options object's properties in
            text form.</summary>
            <returns>A text string containing the values of this options
            object's properties. The format of the string is the same as the
            one described in the String constructor for this class.</returns>
        </member>
        <member name="F:PeterO.Cbor.JSONOptions.Default">
            <summary>The default options for converting CBOR objects to
            JSON.</summary>
        </member>
        <member name="P:PeterO.Cbor.JSONOptions.Base64Padding">
            <summary>Gets a value indicating whether the Base64Padding property
            is true. This property has no effect; in previous versions, this
            property meant that padding was written out when writing base64url
            or traditional base64 to JSON.</summary>
            <value>A value indicating whether the Base64Padding property is
            true.</value>
        </member>
        <member name="P:PeterO.Cbor.JSONOptions.ReplaceSurrogates">
            <summary>Gets a value indicating whether surrogate code points not
            part of a surrogate pair (which consists of two consecutive
            <c>char</c> s forming one Unicode code point) are each replaced
            with a replacement character (U+FFFD). The default is false; an
            exception is thrown when such code points are
            encountered.</summary>
            <value>True, if surrogate code points not part of a surrogate pair
            are each replaced with a replacement character, or false if an
            exception is thrown when such code points are encountered.</value>
        </member>
        <member name="T:PeterO.Cbor.ICBORToFromConverter`1">
            <summary>Classes that implement this interface can support
            conversions from CBOR objects to a custom type and back.</summary>
            <typeparam name='T'>Type of objects to convert to and from CBOR
            objects.</typeparam>
        </member>
        <member name="M:PeterO.Cbor.ICBORToFromConverter`1.FromCBORObject(PeterO.Cbor.CBORObject)">
            <summary>Converts a CBOR object to a custom type.</summary>
            <param name='obj'>A CBOR object to convert to the custom
            type.</param>
            <returns>An object of the custom type after conversion.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORUuidConverter.ToCBORObject(System.Guid)">
            <summary>Internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            internal parameter.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="T:PeterO.Cbor.CBORType">
            <summary>Represents a type that a CBOR object can have.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.Number">
            <summary>A number of any kind, including integers, big integers,
            floating point numbers, and decimal numbers. The floating-point
            value Not-a-Number is also included in the Number type.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.Boolean">
            <summary>The simple values true and false.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.SimpleValue">
            <summary>A "simple value" other than floating point values, true,
            and false.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.ByteString">
            <summary>An array of bytes.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.TextString">
            <summary>A text string.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.Array">
            <summary>An array of CBOR objects.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.Map">
            <summary>A map of CBOR objects.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.Integer">
            <summary>An integer in the interval [-(2^64), 2^64 - 1], or an
            integer of major type 0 and 1.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORType.FloatingPoint">
            <summary>A 16-, 32-, or 64-bit binary floating-point
            number.</summary>
        </member>
        <member name="T:PeterO.Cbor.CBORObject">
            <summary>
            <para>Represents an object in Concise Binary Object Representation
            (CBOR) and contains methods for reading and writing CBOR data. CBOR
            is defined in RFC 7049.</para></summary>
            <remarks>
            <para><b>Converting CBOR objects</b></para>
            <para>There are many ways to get a CBOR object, including from
            bytes, objects, streams and JSON, as described below.</para>
            <para><b>To and from byte arrays:</b> The
            CBORObject.DecodeFromBytes method converts a byte array in CBOR
            format to a CBOR object. The EncodeToBytes method converts a CBOR
            object to its corresponding byte array in CBOR format.</para>
            <para><b>To and from data streams:</b> The CBORObject.Write methods
            write many kinds of objects to a data stream, including numbers,
            CBOR objects, strings, and arrays of numbers and strings. The
            CBORObject.Read method reads a CBOR object from a data
            stream.</para>
            <para><b>To and from other objects:</b> The
            <c>CBORObject.FromObject</c> method converts many kinds of objects
            to a CBOR object, including numbers, strings, and arrays and maps
            of numbers and strings. Methods like AsDouble, AsByte, and AsString
            convert a CBOR object to different types of object. The
            <c>CBORObject.ToObject</c> method converts a CBOR object to an
            object of a given type; for example, a CBOR array to a native
            <c>List</c> (or <c>ArrayList</c> in Java), or a CBOR integer to an
            <c>int</c> or <c>long</c>.</para>
            <para><b>To and from JSON:</b> This class also doubles as a reader
            and writer of JavaScript Object Notation (JSON). The
            CBORObject.FromJSONString method converts JSON to a CBOR object,
            and the ToJSONString method converts a CBOR object to a JSON
            string. (Note that the conversion from CBOR to JSON is not always
            without loss and may make it impossible to recover the original
            object when converting the JSON back to CBOR. See the ToJSONString
            documentation.)</para>
            <para>In addition, the CBORObject.WriteJSON method writes many
            kinds of objects as JSON to a data stream, including numbers, CBOR
            objects, strings, and arrays of numbers and strings. The
            CBORObject.Read method reads a CBOR object from a JSON data
            stream.</para>
            <para><b>Comparison Considerations:</b></para>
            <para>Instances of CBORObject should not be compared for equality
            using the "==" operator; it's possible to create two CBOR objects
            with the same value but not the same reference. (The "==" operator
            might only check if each side of the operator is the same
            instance.)</para>
            <para>This class's natural ordering (under the CompareTo method) is
            consistent with the Equals method, meaning that two values that
            compare as equal under the CompareTo method are also equal under
            the Equals method; this is a change in version 4.0. Two otherwise
            equal objects with different tags are not treated as equal by both
            CompareTo and Equals. To strip the tags from a CBOR object before
            comparing, use the <c>Untag</c> method.</para>
            <para><b>Thread Safety:</b></para>
            <para>Certain CBOR objects are immutable (their values can't be
            changed), so they are inherently safe for use by multiple
            threads.</para>
            <para>CBOR objects that are arrays, maps, and byte strings
            (including tagged objects that represent numbers) are mutable, but
            this class doesn't attempt to synchronize reads and writes to those
            objects by multiple threads, so those objects are not thread safe
            without such synchronization.</para>
            <para>One kind of CBOR object is called a map, or a list of
            key-value pairs. Keys can be any kind of CBOR object, including
            numbers, strings, arrays, and maps. However, untagged text strings
            (which means GetTags returns an empty array and the Type property,
            or "getType()" in Java, returns TextString) are the most suitable
            to use as keys; other kinds of CBOR object are much better used as
            map values instead, keeping in mind that some of them are not
            thread safe without synchronizing reads and writes to them.</para>
            <para>To find the type of a CBOR object, call its Type property (or
            "getType()" in Java). The return value can be Integer,
            FloatingPoint, Boolean, SimpleValue, or TextString for immutable
            CBOR objects, and Array, Map, or ByteString for mutable CBOR
            objects.</para>
            <para><b>Nesting Depth:</b></para>
            <para>The DecodeFromBytes and Read methods can only read objects
            with a limited maximum depth of arrays and maps nested within other
            arrays and maps. The code sets this maximum depth to 500 (allowing
            more than enough nesting for most purposes), but it's possible that
            stack overflows in some runtimes might lower the effective maximum
            nesting depth. When the nesting depth goes above 500, the
            DecodeFromBytes and Read methods throw a CBORException.</para>
            <para>The ReadJSON and FromJSONString methods currently have
            nesting depths of 1000.</para></remarks>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_LessThan(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Returns whether one object's value is less than
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is less than another's;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_LessThanOrEqual(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Returns whether one object's value is up to
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is up to another's;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_GreaterThan(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Returns whether one object's value is greater than
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is greater than
            another's; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_GreaterThanOrEqual(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Returns whether one object's value is at least
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is at least another's;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsUInt16">
            <summary>Converts this object to a 16-bit unsigned integer. The
            return value will be truncated as necessary.</summary>
            <returns>A 16-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is outside
            the range of a 16-bit unsigned integer.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsUInt32">
            <summary>Converts this object to a 32-bit unsigned integer. The
            return value will be truncated as necessary.</summary>
            <returns>A 32-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is outside
            the range of a 32-bit unsigned integer.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsSByte">
            <summary>Converts this object to an 8-bit signed integer.</summary>
            <returns>An 8-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.UInt32)">
            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 32-bit unsigned integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param>
            <param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.UInt64)">
            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 64-bit unsigned integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param>
            <param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='majorType'/> is 7 and value is greater than 255.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsDecimal">
            <summary>Converts this object to a.NET decimal.</summary>
            <returns>The closest big integer to this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='T:System.OverflowException'>This object's value exceeds the
            range of a.NET decimal.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsUInt64">
            <summary>Not documented yet.</summary>
            <summary>Converts this object to a 64-bit unsigned integer after
            discarding any fractional part, if any, from its value.</summary>
            <returns>A 64-bit unsigned integer.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='T:System.OverflowException'>This object's value, if
            truncated to an integer, is outside the range of a 64-bit unsigned
            integer.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.SByte,System.IO.Stream)">
            <summary>Writes an 8-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The parameter <paramref name='value'/> is an
            8-bit signed integer.</param>
            <param name='stream'>A writable data stream.</param>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.UInt64,System.IO.Stream)">
            <summary>Writes a 64-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 64-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Decimal)">
            <summary>Converts a.NET decimal to a CBOR object.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            Decimal object.</param>
            <returns>A CBORObject object with the same value as the.NET
            decimal.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.UInt32,System.IO.Stream)">
            <summary>Writes a 32-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 32-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.UInt16,System.IO.Stream)">
            <summary>Writes a 16-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 16-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.SByte)">
            <summary>Converts a signed 8-bit integer to a CBOR
            object.</summary>
            <param name='value'>The parameter <paramref name='value'/> is an
            8-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 64-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt32)">
            <summary>Converts a 32-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 32-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 16-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.UInt64)">
            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary>
            <param name='o'>The parameter <paramref name='o'/> is an arbitrary
            object, which can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='tag'>A 64-bit integer that specifies a tag number. The
            tag number 55799 can be used to mark a "self-described CBOR"
            object. This document does not attempt to list all CBOR tags and
            their meanings. An up-to-date list can be found at the CBOR Tags
            registry maintained by the Internet Assigned Numbers Authority (
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object where the object <paramref name='o'/> is
            converted to a CBOR object and given the tag <paramref name='tag'/>
            . If "valueOb" is null, returns a version of CBORObject.Null with
            the given tag.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToObject``1">
            <summary>
            <para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>The converted object.</returns>
            <exception cref='T:System.NotSupportedException'>The given type "T", or this
            object's CBOR type, is not supported.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.CBORTypeMapper)">
            <summary>
            <para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>The converted object.</returns>
            <exception cref='T:System.NotSupportedException'>The given type "T", or this
            object's CBOR type, is not supported.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.PODOptions)">
            <summary>
            <para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary>
            <param name='options'>Specifies options for controlling
            deserialization of CBOR objects.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>The converted object.</returns>
            <exception cref='T:System.NotSupportedException'>The given type "T", or this
            object's CBOR type, is not supported.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">
            <summary>
            <para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types.</param>
            <param name='options'>Specifies options for controlling
            deserialization of CBOR objects.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>The converted object.</returns>
            <exception cref='T:System.NotSupportedException'>The given type "T", or this
            object's CBOR type, is not supported.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Adds two CBOR objects and returns their result.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The sum of the two objects.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_Subtraction(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Subtracts a CBORObject object from a CBORObject
            object.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The difference of the two objects.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Multiplies a CBORObject object by the value of a
            CBORObject object.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The product of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_Division(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Divides a CBORObject object by the value of a CBORObject
            object.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The quotient of the two objects.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.op_Modulus(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Finds the remainder that results when a CBORObject object
            is divided by the value of a CBORObject object.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The remainder of the two numbers.</returns>
        </member>
        <member name="F:PeterO.Cbor.CBORObject.False">
            <summary>Represents the value false.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORObject.NaN">
            <summary>A not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORObject.NegativeInfinity">
            <summary>The value negative infinity.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORObject.Null">
            <summary>Represents the value null.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORObject.PositiveInfinity">
            <summary>The value positive infinity.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORObject.True">
            <summary>Represents the value true.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORObject.Undefined">
            <summary>Represents the value undefined.</summary>
        </member>
        <member name="F:PeterO.Cbor.CBORObject.Zero">
            <summary>Gets a CBOR object for the number zero.</summary>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.Count">
            <summary>Gets the number of keys in this map, or the number of
            items in this array, or 0 if this item is neither an array nor a
            map.</summary>
            <value>The number of keys in this map, or the number of items in
            this array, or 0 if this item is neither an array nor a
            map.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.MostInnerTag">
            <summary>Gets the last defined tag for this CBOR data item, or -1
            if the item is untagged.</summary>
            <value>The last defined tag for this CBOR data item, or -1 if the
            item is untagged.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsFalse">
            <summary>Gets a value indicating whether this value is a CBOR false
            value, whether tagged or not.</summary>
            <value><c>true</c> if this value is a CBOR false value; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsFinite">
            <summary>Gets a value indicating whether this CBOR object
            represents a finite number.</summary>
            <value><c>true</c> if this CBOR object represents a finite number;
            otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsIntegral">
            <summary>Gets a value indicating whether this object represents an
            integer number, that is, a number without a fractional part.
            Infinity and not-a-number are not considered integers.</summary>
            <value><c>true</c> if this object represents an integer number,
            that is, a number without a fractional part; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsNull">
            <summary>Gets a value indicating whether this value is a CBOR null
            value.</summary>
            <value><c>true</c> if this value is a CBOR null value; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsTagged">
            <summary>Gets a value indicating whether this data item has at
            least one tag.</summary>
            <value><c>true</c> if this data item has at least one tag;
            otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsTrue">
            <summary>Gets a value indicating whether this value is a CBOR true
            value, whether tagged or not.</summary>
            <value><c>true</c> if this value is a CBOR true value; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsUndefined">
            <summary>Gets a value indicating whether this value is a CBOR
            undefined value.</summary>
            <value><c>true</c> if this value is a CBOR undefined value;
            otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsZero">
            <summary>Gets a value indicating whether this object's value equals
            0.</summary>
            <value><c>true</c> if this object's value equals 0; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.Keys">
            <summary>Gets a collection of the keys of this CBOR object in an
            undefined order.</summary>
            <value>A collection of the keys of this CBOR object.</value>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            map.</exception>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsNegative">
            <summary>Gets a value indicating whether this object is a negative
            number.</summary>
            <value><c>true</c> if this object is a negative number; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.MostOuterTag">
            <summary>Gets the outermost tag for this CBOR data item, or -1 if
            the item is untagged.</summary>
            <value>The outermost tag for this CBOR data item, or -1 if the item
            is untagged.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.Sign">
            <summary>Gets this value's sign: -1 if negative; 1 if positive; 0
            if zero.</summary>
            <value>This value's sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number, or this object is a not-a-number (NaN)
            value.</exception>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.SimpleValue">
            <summary>Gets the simple value ID of this object, or -1 if this
            object is not a simple value (including if the value is a
            floating-point number).</summary>
            <value>The simple value ID of this object, or -1 if this object is
            not a simple value (including if the value is a floating-point
            number).</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.IsNumber">
            <summary>Gets a value indicating whether this CBOR object stores a
            number (including infinity or a not-a-number or NaN value).
            Currently, this is true if this item is untagged and has a CBORType
            of Integer or FloatingPoint, or if this item has only one tag and
            that tag is 2, 3, 4, 5, 30, 264, 265, 268, 269, or 270 with the
            right data type.</summary>
            <value>A value indicating whether this CBOR object stores a
            number.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.Type">
            <summary>Gets the general data type of this CBOR object. This
            method disregards the tags this object has, if any.</summary>
            <value>The general data type of this CBOR object.</value>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.Values">
            <summary>Gets a collection of the values of this CBOR object, if
            it's a map or an array. If this object is a map, returns one value
            for each key in the map in an undefined order. If this is an array,
            returns all the values of the array in the order they are listed.
            (This method can't be used to get the bytes in a CBOR byte string;
            for that, use the GetByteString method instead.).</summary>
            <value>A collection of the values of this CBOR map or
            array.</value>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            map or an array.</exception>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.Item(System.Int32)">
            <summary>Gets the value of a CBOR object by integer index in this
            array or by integer key in this map.</summary>
            <param name='index'>Index starting at 0 of the element, or the
            integer key to this map. (If this is a map, the given index can be
            any 32-bit signed integer, even a negative one.).</param>
            <returns>The CBOR object referred to by index or key in this array
            or map. If this is a CBOR map, returns null if an item with the
            given key doesn't exist.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is not an
            array or map.</exception>
            <exception cref='T:System.ArgumentException'>This object is an array and the
            index is less than 0 or at least the size of the array.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter "value" is
            null (as opposed to CBORObject.Null).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.GetOrDefault(System.Object,PeterO.Cbor.CBORObject)">
            <summary>Gets the value of a CBOR object by integer index in this
            array or by CBOR object key in this map, or a default value if that
            value is not found.</summary>
            <param name='key'>An arbitrary object. If this is a CBOR map, this
            parameter is converted to a CBOR object serving as the key to the
            map or index to the array, and can be null. If this is a CBOR
            array, the key must be an integer 0 or greater and less than the
            size of the array, and may be any object convertible to a CBOR
            integer.</param>
            <param name='defaultValue'>A value to return if an item with the
            given key doesn't exist, or if the CBOR object is an array and the
            key is not an integer 0 or greater and less than the size of the
            array.</param>
            <returns>The CBOR object referred to by index or key in this array
            or map. If this is a CBOR map, returns null if an item with the
            given key doesn't exist.</returns>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.Item(PeterO.Cbor.CBORObject)">
            <summary>Gets the value of a CBOR object by integer index in this
            array or by CBOR object key in this map.</summary>
            <param name='key'>A CBOR object serving as the key to the map or
            index to the array. If this is a CBOR array, the key must be an
            integer 0 or greater and less than the size of the array.</param>
            <returns>The CBOR object referred to by index or key in this array
            or map. If this is a CBOR map, returns null if an item with the
            given key doesn't exist.</returns>
            <exception cref='T:System.ArgumentNullException'>The key is null (as opposed
            to CBORObject.Null); or the set method is called and the value is
            null.</exception>
            <exception cref='T:System.ArgumentException'>This CBOR object is an array
            and the key is not an integer 0 or greater and less than the size
            of the array.</exception>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            map or an array.</exception>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.Item(System.String)">
            <summary>Gets the value of a CBOR object in this map, using a
            string as the key.</summary>
            <param name='key'>A key that points to the desired value.</param>
            <returns>The CBOR object referred to by key in this map. Returns
            <c>null</c> if an item with the given key doesn't exist.</returns>
            <exception cref='T:System.ArgumentNullException'>The key is
            null.</exception>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            map.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Finds the sum of two CBOR numbers.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentException'>Either or both operands are not
            numbers (as opposed to Not-a-Number, NaN).</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[])">
            <summary>
            <para>Generates a CBOR object from an array of CBOR-encoded
            bytes.</para></summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <returns>A CBOR object decoded from the given byte array.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is
            empty.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='data'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.DecodeSequenceFromBytes(System.Byte[])">
            <summary>
            <para>Generates a sequence of CBOR objects from an array of
            CBOR-encoded bytes.</para></summary>
            <param name='data'>A byte array in which any number of CBOR objects
            (including zero) are encoded, one after the other. Can be empty,
            but cannot be null.</param>
            <returns>An array of CBOR objects decoded from the given byte
            array. Returns an empty array if <paramref name='data'/> is
            empty.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where the last
            CBOR object in the data was read only partly.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='data'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.DecodeSequenceFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions)">
            <summary>
            <para>Generates a sequence of CBOR objects from an array of
            CBOR-encoded bytes.</para></summary>
            <param name='data'>A byte array in which any number of CBOR objects
            (including zero) are encoded, one after the other. Can be empty,
            but cannot be null.</param>
            <param name='options'>Specifies options to control how the CBOR
            object is decoded. See
            <see cref='T:PeterO.Cbor.CBOREncodeOptions'/> for more information.
            In this method, the AllowEmpty property is treated as always set
            regardless of that value as specified in this parameter.</param>
            <returns>An array of CBOR objects decoded from the given byte
            array. Returns an empty array if <paramref name='data'/> is
            empty.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where the last
            CBOR object in the data was read only partly.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='data'/> is null, or the parameter <paramref name='options'/>
            is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions)">
            <summary>Generates a CBOR object from an array of CBOR-encoded
            bytes, using the given <c>CBOREncodeOptions</c>
             object to control
            the decoding process.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='options'>Specifies options to control how the CBOR
            object is decoded. See <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
            for more information.</param>
            <returns>A CBOR object decoded from the given byte array. Returns
            null (as opposed to CBORObject.Null) if <paramref name='data'/> is
            empty and the AllowEmpty property is set on the given options
            object.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='data'/> is null, or the parameter <paramref name='options'/>
            is null.</exception>
            <example>
            <para>The following example (originally written in C# for the.NET
            version) implements a method that decodes a text string from a CBOR
            byte array. It's successful only if the CBOR object contains an
            untagged text string.</para>
            <code>private static String DecodeTextString(byte[] bytes) { if (bytes ==
            null) { throw new ArgumentNullException(nameof(mapObj));}
            if
            (bytes.Length == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f) {throw new
            CBORException();} return CBORObject.DecodeFromBytes(bytes,
            CBOREncodeOptions.Default).AsString(); }</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Divide(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Divides a CBORObject object by the value of a CBORObject
            object.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>The quotient of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String)">
            <summary>
            <para>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format.</para>
            <para>If a JSON object has duplicate keys, a CBORException is
            thrown. This is a change in version 4.0.</para>
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONString</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='str'>A string in JSON format. The entire string must
            contain a single JSON object and not multiple objects. The string
            may not begin with a byte-order mark (U+FEFF).</param>
            <returns>A CBOR object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String,PeterO.Cbor.CBOREncodeOptions)">
            <summary>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process.
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONString</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='str'>A string in JSON format. The entire string must
            contain a single JSON object and not multiple objects. The string
            may not begin with a byte-order mark (U+FEFF).</param>
            <param name='options'>Specifies options to control the decoding
            process.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> or <paramref name='options'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToObject(System.Type)">
            <summary>Converts this CBOR object to an object of an arbitrary
            type. See the documentation for the overload of this method taking
            a CBORTypeMapper parameter for more information. This method
            doesn't use a CBORTypeMapper parameter to restrict which data types
            are eligible for Plain-Old-Data serialization.</summary>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b>
             For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method (such as <c>int</c>
             or
            <c>String</c>
             ) or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <returns>The converted object.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>The given type
            <paramref name='t'/> , or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='t'/> is null.</exception>
            <example>
            <para>Java offers no easy way to express a generic type, at least
            none as easy as C#'s <c>typeof</c>
             operator. The following example,
            written in Java, is a way to specify that the return value will be
            an ArrayList of String objects.</para>
            <code>Type arrayListString = new ParameterizedType() { public Type[]
            getActualTypeArguments() { /* Contains one type parameter, String */ return
            new Type[] { String.class }; } public Type getRawType() { /* Raw type is
            ArrayList */ return ArrayList.class; } public Type getOwnerType() {
            return null; } }; ArrayList&lt;String&gt; array =
            (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);</code>
            <para>By comparison, the C# version is much shorter.</para>
            <code>var array = (List&lt;String&gt;)cborArray.ToObject(
            typeof(List&lt;String&gt;));</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.CBORTypeMapper)">
            <summary>Converts this CBOR object to an object of an arbitrary
            type. See the documentation for the overload of this method taking
            a CBORTypeMapper and PODOptions parameters parameters for more
            information.</summary>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method (such as <c>int</c> or
            <c>String</c> ) or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types.</param>
            <returns>The converted object.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>The given type
            <paramref name='t'/>, or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='t'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.PODOptions)">
            <summary>Converts this CBOR object to an object of an arbitrary
            type. See the documentation for the overload of this method taking
            a CBORTypeMapper and PODOptions parameters for more information.
            This method (without a CBORTypeMapper parameter) allows all data
            types not otherwise handled to be eligible for Plain-Old-Data
            serialization.</summary>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method (such as <c>int</c> or
            <c>String</c> ) or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <param name='options'>Specifies options for controlling
            deserialization of CBOR objects.</param>
            <returns>The converted object.</returns>
            <exception cref='T:System.NotSupportedException'>The given type <paramref
            name='t'/>, or this object's CBOR type, is not
            supported.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='t'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The given object's
            nesting is too deep, or another error occurred when serializing the
            object.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">
            <summary><para>Converts this CBOR object to an object of an
            arbitrary type. The following cases are checked in the logical
            order given (rather than the strict order in which they are
            implemented by this library):</para>
             <list><item>If the type is
            <c>CBORObject</c>
             , return this object.</item>
             <item>If the given
            object is <c>CBORObject.Null</c>
             (with or without tags), returns
            <c>null</c>
             .</item>
             <item>If the object is of a type corresponding
            to a type converter mentioned in the <paramref name='mapper'/>
            parameter, that converter will be used to convert the CBOR object
            to an object of the given type. Type converters can be used to
            override the default conversion behavior of almost any
            object.</item>
             <item>If the type is <c>object</c>
             , return this
            object.</item>
             <item>If the type is <c>char</c>
             , converts
            single-character CBOR text strings and CBOR integers from 0 through
            65535 to a <c>char</c>
             object and returns that <c>char</c>
            object.</item>
             <item>If the type is <c>bool</c>
             ( <c>boolean</c>
             in
            Java), returns the result of AsBoolean.</item>
             <item>If the type is
            a primitive integer type ( <c>byte</c>
             , <c>int</c>
             , <c>short</c>
            , <c>long</c>
             , as well as <c>sbyte</c>
             , <c>ushort</c>
             ,
            <c>uint</c>
             , and <c>ulong</c>
             in.NET) or a primitive
            floating-point type ( <c>float</c>
             , <c>double</c>
             , as well as
            <c>decimal</c>
             in.NET), returns the result of the corresponding As*
            method.</item>
             <item>If the type is <c>String</c>
             , returns the
            result of AsString.</item>
             <item>If the type is <c>EDecimal</c>
             ,
            <c>EFloat</c>
             , <c>EInteger</c>
             , or <c>ERational</c>
             in the <a
            href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c>
            </a>
             library (in .NET) or the <a
            href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c>
            </a>
             artifact (in Java), returns the result of the corresponding
            As* method.</item>
             <item>In the.NET version, if the type is a
            nullable (e.g., <c>Nullable&lt;int&gt;</c>
             or <c>int?</c>
             , returns
            <c>null</c>
             if this CBOR object is null, or this object's value
            converted to the nullable's underlying type, e.g., <c>int</c>
            .</item>
             <item>If the type is an enumeration ( <c>Enum</c>
             ) type
            and this CBOR object is a text string or an integer, returns the
            appropriate enumerated constant. (For example, if <c>MyEnum</c>
            includes an entry for <c>MyValue</c>
             , this method will return
            <c>MyEnum.MyValue</c>
             if the CBOR object represents
            <c>"MyValue"</c>
             or the underlying value for <c>MyEnum.MyValue</c>
            .) <b>Note:</b>
             If an integer is converted to a.NET Enum constant,
            and that integer is shared by more than one constant of the same
            type, it is undefined which constant from among them is returned.
            (For example, if <c>MyEnum.Zero=0</c>
             and <c>MyEnum.Null=0</c>
             ,
            converting 0 to <c>MyEnum</c>
             may return either <c>MyEnum.Zero</c>
            or <c>MyEnum.Null</c>
             .) As a result, .NET Enum types with
            constants that share an underlying value should not be passed to
            this method.</item>
             <item>If the type is <c>byte[]</c>
             (a
            one-dimensional byte array) and this CBOR object is a byte string,
            returns a byte array which this CBOR byte string's data will be
            copied to. (This method can't be used to encode CBOR data to a byte
            array; for that, use the EncodeToBytes method instead.)</item>
            <item>If the type is a one-dimensional or multidimensional array
            type and this CBOR object is an array, returns an array containing
            the items in this CBOR object.</item>
             <item>If the type is List or
            the generic or non-generic IList, ICollection, or IEnumerable, (or
            ArrayList, List, Collection, or Iterable in Java), and if this CBOR
            object is an array, returns an object conforming to the type,
            class, or interface passed to this method, where the object will
            contain all items in this CBOR array.</item>
             <item>If the type is
            Dictionary or the generic or non-generic IDictionary (or HashMap or
            Map in Java), and if this CBOR object is a map, returns an object
            conforming to the type, class, or interface passed to this method,
            where the object will contain all keys and values in this CBOR
            map.</item>
             <item>If the type is an enumeration constant ("enum"),
            and this CBOR object is an integer or text string, returns the
            enumeration constant with the given number or name, respectively.
            (Enumeration constants made up of multiple enumeration constants,
            as allowed by .NET, can only be matched by number this way.)</item>
            <item>If the type is <c>DateTime</c>
             (or <c>Date</c>
             in Java) ,
            returns a date/time object if the CBOR object's outermost tag is 0
            or 1. For tag 1, this method treats the CBOR object as a number of
            seconds since the start of 1970, which is based on the POSIX
            definition of "seconds since the Epoch", a definition that does not
            count leap seconds. In this method, this number of seconds assumes
            the use of a proleptic Gregorian calendar, in which the rules
            regarding the number of days in each month and which years are leap
            years are the same for all years as they were in 1970 (including
            without regard to transitions from other calendars to the
            Gregorian). For tag 1, CBOR objects that express infinity or
            not-a-number (NaN) are treated as invalid by this method.</item>
            <item>If the type is <c>Uri</c>
             (or <c>URI</c>
             in Java), returns a
            URI object if possible.</item>
             <item>If the type is <c>Guid</c>
             (or
            <c>UUID</c>
             in Java), returns a UUID object if possible.</item>
            <item>Plain-Old-Data deserialization: If the object is a type not
            specially handled above, the type includes a zero-parameter
            constructor (default or not), this CBOR object is a CBOR map, and
            the "mapper" parameter (if any) allows this type to be eligible for
            Plain-Old-Data deserialization, then this method checks the given
            type for eligible setters as follows:</item>
             <item>(*) In the .NET
            version, eligible setters are the public, nonstatic setters of
            properties with a public, nonstatic getter. Eligible setters also
            include public, nonstatic, non- <c>const</c>
             , non- <c>readonly</c>
            fields. If a class has two properties and/or fields of the form "X"
            and "IsX", where "X" is any name, or has multiple properties and/or
            fields with the same name, those properties and fields are
            ignored.</item>
             <item>(*) In the Java version, eligible setters are
            public, nonstatic methods starting with "set" followed by a
            character other than a basic digit or lower-case letter, that is,
            other than "a" to "z" or "0" to "9", that take one parameter. The
            class containing an eligible setter must have a public, nonstatic
            method with the same name, but starting with "get" or "is" rather
            than "set", that takes no parameters and does not return void. (For
            example, if a class has "public setValue(String)" and "public
            getValue()", "setValue" is an eligible setter. However,
            "setValue()" and "setValue(String, int)" are not eligible setters.)
            In addition, public, nonstatic, nonfinal fields are also eligible
            setters. If a class has two or more otherwise eligible setters
            (methods and/or fields) with the same name, but different parameter
            type, they are not eligible setters.</item>
             <item>Then, the method
            creates an object of the given type and invokes each eligible
            setter with the corresponding value in the CBOR map, if any. Key
            names in the map are matched to eligible setters according to the
            rules described in the <see cref='T:PeterO.Cbor.PODOptions'/>
            documentation. Note that for security reasons, certain types are
            not supported even if they contain eligible setters. For the Java
            version, the object creation may fail in the case of a nested
            nonstatic class.</item>
             </list>
             </summary>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b>
             For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method, such as <c>int</c>
             or
            <c>String</c>
             , or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types. Can be
            null.</param>
            <param name='options'>Specifies options for controlling
            deserialization of CBOR objects.</param>
            <returns>The converted object.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>The given type
            <paramref name='t'/> , or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='t'/> or <paramref name='options'/> is null.</exception>
            <example>
            <para>Java offers no easy way to express a generic type, at least
            none as easy as C#'s <c>typeof</c>
             operator. The following example,
            written in Java, is a way to specify that the return value will be
            an ArrayList of String objects.</para>
            <code>Type arrayListString = new ParameterizedType() { public Type[]
            getActualTypeArguments() { /* Contains one type parameter, String */ return
            new Type[] { String.class }; } public Type getRawType() { /* Raw type is
            ArrayList */ return ArrayList.class; } public Type getOwnerType() {
            return null; } }; ArrayList&lt;String&gt; array =
            (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);</code>
            <para>By comparison, the C# version is much shorter.</para>
            <code>var array = (List&lt;String&gt;)cborArray.ToObject(
            typeof(List&lt;String&gt;));</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Int64)">
            <summary>Generates a CBOR object from a 64-bit signed
            integer.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            64-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject)">
            <summary>Generates a CBOR object from a CBOR object.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            CBOR object.</param>
            <returns>Same as.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EInteger)">
            <summary>Generates a CBOR object from an arbitrary-precision
            integer. The CBOR object is generated as follows:
            <list>
            <item>If the number is null, returns CBORObject.Null.</item>
            <item>Otherwise, if the number is greater than or equal to -(2^64)
            and less than 2^64, the CBOR object will have the object type
            Integer and the appropriate value.</item>
            <item>Otherwise, the CBOR object will have tag 2 (zero or positive)
            or 3 (negative) and the appropriate value.</item></list></summary>
            <param name='bigintValue'>An arbitrary-precision integer. Can be
            null.</param>
            <returns>The given number encoded as a CBOR object. Returns
            CBORObject.Null if <paramref name='bigintValue'/> is
            null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EFloat)">
            <summary>Generates a CBOR object from an arbitrary-precision binary
            floating-point number. The CBOR object is generated as follows
            (this is a change in version 4.0):
            <list>
            <item>If the number is null, returns CBORObject.Null.</item>
            <item>Otherwise, if the number expresses infinity, not-a-number, or
            negative zero, the CBOR object will have tag 269 and the
            appropriate format.</item>
            <item>Otherwise, if the number's exponent is at least 2^64 or less
            than -(2^64), the CBOR object will have tag 265 and the appropriate
            format.</item>
            <item>Otherwise, the CBOR object will have tag 5 and the
            appropriate format.</item></list></summary>
            <param name='bigValue'>An arbitrary-precision binary floating-point
            number. Can be null.</param>
            <returns>The given number encoded as a CBOR object. Returns
            CBORObject.Null if <paramref name='bigValue'/> is null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.ERational)">
            <summary>Generates a CBOR object from an arbitrary-precision
            rational number. The CBOR object is generated as follows (this is a
            change in version 4.0):
            <list>
            <item>If the number is null, returns CBORObject.Null.</item>
            <item>Otherwise, if the number expresses infinity, not-a-number, or
            negative zero, the CBOR object will have tag 270 and the
            appropriate format.</item>
            <item>Otherwise, the CBOR object will have tag 30 and the
            appropriate format.</item></list></summary>
            <param name='bigValue'>An arbitrary-precision rational number. Can
            be null.</param>
            <returns>The given number encoded as a CBOR object. Returns
            CBORObject.Null if <paramref name='bigValue'/> is null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EDecimal)">
            <summary>Generates a CBOR object from a decimal number. The CBOR
            object is generated as follows (this is a change in version 4.0):
            <list>
            <item>If the number is null, returns CBORObject.Null.</item>
            <item>Otherwise, if the number expresses infinity, not-a-number, or
            negative zero, the CBOR object will have tag 268 and the
            appropriate format.</item>
            <item>If the number's exponent is at least 2^64 or less than
            -(2^64), the CBOR object will have tag 264 and the appropriate
            format.</item>
            <item>Otherwise, the CBOR object will have tag 4 and the
            appropriate format.</item></list></summary>
            <param name='bigValue'>An arbitrary-precision decimal number. Can
            be null.</param>
            <returns>The given number encoded as a CBOR object. Returns
            CBORObject.Null if <paramref name='bigValue'/> is null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.String)">
            <summary>Generates a CBOR object from a text string.</summary>
            <param name='strValue'>A string value. Can be null.</param>
            <returns>A CBOR object representing the string, or CBORObject.Null
            if stringValue is null.</returns>
            <exception cref='T:System.ArgumentException'>The string contains an unpaired
            surrogate code point.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Int32)">
            <summary>Generates a CBOR object from a 32-bit signed
            integer.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            32-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Int16)">
            <summary>Generates a CBOR object from a 16-bit signed
            integer.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            16-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Boolean)">
            <summary>Returns the CBOR true value or false value, depending on
            "value".</summary>
            <param name='value'>Either True or False.</param>
            <returns>CBORObject.True if value is true; otherwise
            CBORObject.False.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Byte)">
            <summary>Generates a CBOR object from a byte (0 to 255).</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            byte (from 0 to 255).</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Single)">
            <summary>Generates a CBOR object from a 32-bit floating-point
            number.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            32-bit floating-point number.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Double)">
            <summary>Generates a CBOR object from a 64-bit floating-point
            number.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            64-bit floating-point number.</param>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Byte[])">
            <summary>Generates a CBOR object from an array of 8-bit bytes; the
            byte array is copied to a new byte array in this process. (This
            method can't be used to decode CBOR data from a byte array; for
            that, use the <b>DecodeFromBytes</b> method instead.).</summary>
            <param name='bytes'>An array of 8-bit bytes; can be null.</param>
            <returns>A CBOR object where each element of the given byte array
            is copied to a new array, or CBORObject.Null if the value is
            null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject[])">
            <summary>Generates a CBOR object from an array of CBOR
            objects.</summary>
            <param name='array'>An array of CBOR objects.</param>
            <returns>A CBOR object where each element of the given array is
            copied to a new array, or CBORObject.Null if the value is
            null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Int32[])">
            <summary>Generates a CBOR object from an array of 32-bit
            integers.</summary>
            <param name='array'>An array of 32-bit integers.</param>
            <returns>A CBOR array object where each element of the given array
            is copied to a new array, or CBORObject.Null if the value is
            null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Int64[])">
            <summary>Generates a CBOR object from an array of 64-bit
            integers.</summary>
            <param name='array'>An array of 64-bit integers.</param>
            <returns>A CBOR array object where each element of the given array
            is copied to a new array, or CBORObject.Null if the value is
            null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Object)">
            <summary>Generates a CBORObject from an arbitrary object. See the
            overload of this method that takes CBORTypeMapper and PODOptions
            arguments.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object, which can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.PODOptions)">
            <summary>Generates a CBORObject from an arbitrary object. See the
            overload of this method that takes CBORTypeMapper and PODOptions
            arguments.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='options'>An object containing options to control how
            certain objects are converted to CBOR objects.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='options'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.CBORTypeMapper)">
            <summary>Generates a CBORObject from an arbitrary object. See the
            overload of this method that takes CBORTypeMapper and PODOptions
            arguments.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='mapper'>An object containing optional converters to
            convert objects of certain types to CBOR objects.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='mapper'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">
            <summary>
            <para>Generates a CBORObject from an arbitrary object, using the
            given options to control how certain objects are converted to CBOR
            objects. The following cases are checked in the logical order given
            (rather than the strict order in which they are implemented by this
            library):</para>
            <list>
            <item><c>null</c> is converted to <c>CBORObject.Null</c>.</item>
            <item>A <c>CBORObject</c> is returned as itself.</item>
            <item>If the object is of a type corresponding to a type converter
            mentioned in the <paramref name='mapper'/> parameter, that
            converter will be used to convert the object to a CBOR object. Type
            converters can be used to override the default conversion behavior
            of almost any object.</item>
            <item>A <c>char</c> is converted to an integer (from 0 through
            65535), and returns a CBOR object of that integer. (This is a
            change in version 4.0 from previous versions, which converted
            <c>char</c>, except surrogate code points from 0xd800 through
            0xdfff, into single-character text strings.)</item>
            <item>A <c>bool</c> ( <c>boolean</c> in Java) is converted to
            <c>CBORObject.True</c> or <c>CBORObject.False</c>.</item>
            <item>A <c>byte</c> is converted to a CBOR integer from 0 through
            255.</item>
            <item>A primitive integer type ( <c>int</c>, <c>short</c>,
            <c>long</c>, as well as <c>sbyte</c>, <c>ushort</c>, <c>uint</c>
            , and <c>ulong</c> in.NET) is converted to the corresponding CBOR
            integer.</item>
            <item>A primitive floating-point type ( <c>float</c>,
            <c>double</c>, as well as <c>decimal</c> in.NET) is converted to
            the corresponding CBOR number.</item>
            <item>A <c>String</c> is converted to a CBOR text string. To create
            a CBOR byte string object from <c>String</c>, see the example
            given in
            <see
            cref='M:PeterO.Cbor.CBORObject.FromObject(System.Byte[])'/>.</item>
            <item>In the.NET version, a nullable is converted to
            <c>CBORObject.Null</c> if the nullable's value is <c>null</c>, or
            converted according to the nullable's underlying type, if that type
            is supported by this method.</item>
            <item>A number of type <c>EDecimal</c>, <c>EFloat</c>,
            <c>EInteger</c>, and <c>ERational</c> in the
            <a
              href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c></a>
            library (in .NET) or the
            <a
              href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
            artifact (in Java) is converted to the corresponding CBOR
            number.</item>
            <item>An array other than <c>byte[]</c> is converted to a CBOR
            array. In the.NET version, a multidimensional array is converted to
            an array of arrays.</item>
            <item>A <c>byte[]</c> (1-dimensional byte array) is converted to a
            CBOR byte string; the byte array is copied to a new byte array in
            this process. (This method can't be used to decode CBOR data from a
            byte array; for that, use the <b>DecodeFromBytes</b> method
            instead.)</item>
            <item>An object implementing IDictionary (Map in Java) is converted
            to a CBOR map containing the keys and values enumerated.</item>
            <item>An object implementing IEnumerable (Iterable in Java) is
            converted to a CBOR array containing the items enumerated.</item>
            <item>An enumeration ( <c>Enum</c> ) object is converted to its
            <i>underlying value</i> in the.NET version, or the result of its
            <c>ordinal()</c> method in the Java version.</item>
            <item>An object of type <c>DateTime</c>, <c>Uri</c>, or
            <c>Guid</c> ( <c>Date</c>, <c>URI</c>, or <c>UUID</c>,
            respectively, in Java) will be converted to a tagged CBOR object of
            the appropriate kind. <c>DateTime</c> / <c>Date</c> will be
            converted to a tag-0 string following the date format used in the
            Atom syndication format.</item>
            <item>If the object is a type not specially handled above, this
            method checks the <paramref name='obj'/> parameter for eligible
            getters as follows:</item>
            <item>(*) In the .NET version, eligible getters are the public,
            nonstatic getters of read/write properties (and also those of
            read-only properties in the case of a compiler-generated type).
            Eligible getters also include public, nonstatic, non- <c>const</c>
            , non- <c>readonly</c> fields. If a class has two properties and/or
            fields of the form "X" and "IsX", where "X" is any name, or has
            multiple properties and/or fields with the same name, those
            properties and fields are ignored.</item>
            <item>(*) In the Java version, eligible getters are public,
            nonstatic methods starting with "get" or "is" (either word followed
            by a character other than a basic digit or lower-case letter, that
            is, other than "a" to "z" or "0" to "9"), that take no parameters
            and do not return void, except that methods named "getClass" are
            not eligible getters. In addition, public, nonstatic, nonfinal
            fields are also eligible getters. If a class has two otherwise
            eligible getters (methods and/or fields) of the form "isX" and
            "getX", where "X" is the same in both, or two such getters with the
            same name but different return type, they are not eligible
            getters.</item>
            <item>Then, the method returns a CBOR map with each eligible
            getter's name or property name as each key, and with the
            corresponding value returned by that getter as that key's value.
            Before adding a key-value pair to the map, the key's name is
            adjusted according to the rules described in the
            <see cref='T:PeterO.Cbor.PODOptions'/> documentation. Note that for
            security reasons, certain types are not supported even if they
            contain eligible getters.</item></list>
            <para><b>REMARK:</b>.NET enumeration ( <c>Enum</c> ) constants
            could also have been converted to text strings with
            <c>ToString()</c>, but that method will return multiple names if
            the given Enum object is a combination of Enum objects (e.g. if the
            object is <c>FileAccess.Read | FileAccess.Write</c> ). More
            generally, if Enums are converted to text strings, constants from
            Enum types with the <c>Flags</c> attribute, and constants from the
            same Enum type that share an underlying value, should not be passed
            to this method.</para></summary>
            <param name='obj'>An arbitrary object to convert to a CBOR object.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='mapper'>An object containing optional converters to
            convert objects of certain types to CBOR objects. Can be
            null.</param>
            <param name='options'>An object containing options to control how
            certain objects are converted to CBOR objects.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='options'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>An error occurred while
            converting the given object to a CBOR object.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,PeterO.Numbers.EInteger)">
            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary>
            <param name='valueOb'>The parameter <paramref name='valueOb'/> is
            an arbitrary object, which can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='bigintTag'>Tag number. The tag number 55799 can be
            used to mark a "self-described CBOR" object. This document does not
            attempt to list all CBOR tags and their meanings. An up-to-date
            list can be found at the CBOR Tags registry maintained by the
            Internet Assigned Numbers Authority (
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object where the object <paramref name='valueOb'/>
            is converted to a CBOR object and given the tag <paramref
            name='bigintTag'/>. If <paramref name='valueOb'/> is null, returns
            a version of CBORObject.Null with the given tag.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='bigintTag'/> is less than 0 or greater than
            2^64-1.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigintTag'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.Int32)">
            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary>
            <param name='valueObValue'>The parameter <paramref
            name='valueObValue'/> is an arbitrary object, which can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='smallTag'>A 32-bit integer that specifies a tag
            number. The tag number 55799 can be used to mark a "self-described
            CBOR" object. This document does not attempt to list all CBOR tags
            and their meanings. An up-to-date list can be found at the CBOR
            Tags registry maintained by the Internet Assigned Numbers Authority
            (
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object where the object <paramref
            name='valueObValue'/> is converted to a CBOR object and given the
            tag <paramref name='smallTag'/>. If "valueOb" is null, returns a
            version of CBORObject.Null with the given tag.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='smallTag'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromSimpleValue(System.Int32)">
            <summary>Creates a CBOR object from a simple value
            number.</summary>
            <param name='simpleValue'>The parameter <paramref
            name='simpleValue'/> is a 32-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='simpleValue'/> is less than 0, greater than 255, or from 24
            through 31.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Multiplies two CBOR numbers.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>The product of the two numbers.</returns>
            <exception cref='T:System.ArgumentException'>Either or both operands are not
            numbers (as opposed to Not-a-Number, NaN).</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.NewArray">
            <summary>Creates a new empty CBOR array.</summary>
            <returns>A new CBOR array.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.NewMap">
            <summary>Creates a new empty CBOR map.</summary>
            <returns>A new CBOR map.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ReadSequence(System.IO.Stream)">
            <summary>
            <para>Reads a sequence of objects in CBOR format from a data
            stream. This method will read CBOR objects from the stream until
            the end of the stream is reached or an error occurs, whichever
            happens first.</para></summary>
            <param name='stream'>A readable data stream.</param>
            <returns>An array containing the CBOR objects that were read from
            the data stream. Returns an empty array if there is no unread data
            in the stream.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null, or the parameter "options" is
            null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data, including if the last CBOR object was
            read only partially.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ReadSequence(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
            <summary>
            <para>Reads a sequence of objects in CBOR format from a data
            stream. This method will read CBOR objects from the stream until
            the end of the stream is reached or an error occurs, whichever
            happens first.</para></summary>
            <param name='stream'>A readable data stream.</param>
            <param name='options'>Specifies the options to use when decoding
            the CBOR data stream. See CBOREncodeOptions for more information.
            In this method, the AllowEmpty property is treated as set
            regardless of the value of that property specified in this
            parameter.</param>
            <returns>An array containing the CBOR objects that were read from
            the data stream. Returns an empty array if there is no unread data
            in the stream.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null, or the parameter <paramref
            name='options'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data, including if the last CBOR object was
            read only partially.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Read(System.IO.Stream)">
            <summary>
            <para>Reads an object in CBOR format from a data stream. This
            method will read from the stream until the end of the CBOR object
            is reached or an error occurs, whichever happens
            first.</para></summary>
            <param name='stream'>A readable data stream.</param>
            <returns>A CBOR object that was read.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Read(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
            <summary>Reads an object in CBOR format from a data stream, using
            the specified options to control the decoding process. This method
            will read from the stream until the end of the CBOR object is
            reached or an error occurs, whichever happens first.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='options'>Specifies the options to use when decoding
            the CBOR data stream. See CBOREncodeOptions for more
            information.</param>
            <returns>A CBOR object that was read.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream)">
            <summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be
            in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
            assuming that the first character read must be a byte-order mark or
            a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.)
            <para>If a JSON object has the same key, only the last given value
            will be used for each duplicated key.</para></summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
            <summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be
            in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
            assuming that the first character read must be a byte-order mark or
            a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.)
            <para>By default, if a JSON object has the same key, only the last
            given value will be used for each duplicated key.</para></summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param>
            <param name='options'>The parameter <paramref name='options'/> is a
            CBOREncodeOptions object.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Remainder(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Finds the remainder that results when a CBORObject object
            is divided by the value of a CBORObject object.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>The remainder of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Subtract(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
            <summary>Finds the difference between two CBOR number
            objects.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentException'>Either or both operands are not
            numbers (as opposed to Not-a-Number, NaN).</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream)">
            <summary>
            <para>Writes a string in CBOR format to a data stream. The string
            will be encoded using definite-length encoding regardless of its
            length.</para></summary>
            <param name='str'>The string to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
            <summary>Writes a string in CBOR format to a data stream, using the
            given options to control the encoding process.</summary>
            <param name='str'>The string to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EFloat,System.IO.Stream)">
            <summary>Writes a binary floating-point number in CBOR format to a
            data stream, as though it were converted to a CBOR object via
            CBORObject.FromObject(EFloat) and then written out.</summary>
            <param name='bignum'>An arbitrary-precision binary floating-point
            number. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.ERational,System.IO.Stream)">
            <summary>Writes a rational number in CBOR format to a data stream,
            as though it were converted to a CBOR object via
            CBORObject.FromObject(ERational) and then written out.</summary>
            <param name='rational'>An arbitrary-precision rational number. Can
            be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EDecimal,System.IO.Stream)">
            <summary>Writes a decimal floating-point number in CBOR format to a
            data stream, as though it were converted to a CBOR object via
            CBORObject.FromObject(EDecimal) and then written out.</summary>
            <param name='bignum'>The arbitrary-precision decimal number to
            write. Can be null.</param>
            <param name='stream'>Stream to write to.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EInteger,System.IO.Stream)">
            <summary>Writes a arbitrary-precision integer in CBOR format to a
            data stream.</summary>
            <param name='bigint'>Arbitrary-precision integer to write. Can be
            null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Int64,System.IO.Stream)">
            <summary>Writes a 64-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Int32,System.IO.Stream)">
            <summary>Writes a 32-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Int16,System.IO.Stream)">
            <summary>Writes a 16-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Boolean,System.IO.Stream)">
            <summary>Writes a Boolean value in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Byte,System.IO.Stream)">
            <summary>Writes a byte (0 to 255) in CBOR format to a data stream.
            If the value is less than 24, writes that byte. If the value is 25
            to 255, writes the byte 24, then this byte's value.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Single,System.IO.Stream)">
            <summary>Writes a 32-bit floating-point number in CBOR format to a
            data stream. The number is written using the shortest
            floating-point encoding possible; this is a change from previous
            versions.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Double,System.IO.Stream)">
            <summary>Writes a 64-bit floating-point number in CBOR format to a
            data stream. The number is written using the shortest
            floating-point encoding possible; this is a change from previous
            versions.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(PeterO.Cbor.CBORObject,System.IO.Stream)">
            <summary>Writes a CBOR object to a CBOR data stream.</summary>
            <param name='value'>The value to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream)">
            <summary>
            <para>Writes a CBOR object to a CBOR data stream. See the
            three-parameter Write method that takes a
            CBOREncodeOptions.</para></summary>
            <param name='objValue'>The arbitrary object to be serialized. Can
            be null.</param>
            <param name='stream'>A writable data stream.</param>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
            <summary>Writes an arbitrary object to a CBOR data stream, using
            the specified options for controlling how the object is encoded to
            CBOR data format. If the object is convertible to a CBOR map or a
            CBOR object that contains CBOR maps, the keys to those maps are
            written out to the data stream in an undefined order. The example
            code given in
            <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can
            be used to write out certain keys of a CBOR map in a given order.
            Currently, the following objects are supported:
            <list type=''>
            <item>Lists of CBORObject.</item>
            <item>Maps of CBORObject. The keys to the map are written out to
            the data stream in an undefined order.</item>
            <item>Null.</item>
            <item>Byte arrays, which will always be written as definite-length
            byte strings.</item>
            <item>String objects. The strings will be encoded using
            definite-length encoding regardless of their length.</item>
            <item>Any object accepted by the FromObject static
            methods.</item></list></summary>
            <param name='objValue'>The arbitrary object to be serialized. Can
            be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='output'>A writable data stream.</param>
            <param name='options'>CBOR options for encoding the CBOR object to
            bytes.</param>
            <exception cref='T:System.ArgumentException'>The object's type is not
            supported.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='options'/> or <paramref name='output'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteJSON(System.Object,System.IO.Stream)">
            <summary>Converts an arbitrary object to a string in JavaScript
            Object Notation (JSON) format, as in the ToJSONString method, and
            writes that string to a data stream in UTF-8. If the object is
            convertible to a CBOR map, or to a CBOR object that contains CBOR
            maps, the keys to those maps are written out to the JSON string in
            an undefined order. The example code given in
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
            can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object. Can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='outputStream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Abs">
            <summary>Gets this object's absolute value.</summary>
            <returns>This object's absolute without its negative
            sign.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Add(System.Object,System.Object)">
            <summary>
            <para>Adds a new key and its value to this CBOR map, or adds the
            value if the key doesn't exist.</para>
            <para>NOTE: This method can't be used to add a tag to an existing
            CBOR object. To create a CBOR object with a given tag, call the
            <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object
            and the desired tag number to that method.</para></summary>
            <param name='key'>An object representing the key, which will be
            converted to a CBORObject. Can be null, in which case this value is
            converted to CBORObject.Null.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='key'/> already exists in this map.</exception>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            map.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='key'/> or <paramref name='valueOb'/> has an unsupported
            type.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Add(PeterO.Cbor.CBORObject)">
            <summary><para>Adds a new object to the end of this array. (Used to
            throw ArgumentNullException on a null reference, but now converts
            the null reference to CBORObject.Null, for convenience with the
            Object overload of this method).</para>
             <para>NOTE: This method
            can't be used to add a tag to an existing CBOR object. To create a
            CBOR object with a given tag, call the
            <c>CBORObject.FromObjectAndTag</c>
             method and pass the CBOR object
            and the desired tag number to that method.</para>
             </summary>
            <param name='obj'>The parameter <paramref name='obj'/> is a CBOR
            object.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is not an
            array.</exception>
            <example>
            <para>The following example creates a CBOR array and adds several
            CBOR objects, one of which has a custom CBOR tag, to that array.
            Note the chaining behavior made possible by this method.</para>
            <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False)
            .Add(CBORObject.FromObject(5)) .Add(CBORObject.FromObject("text
            string")) .Add(CBORObject.FromObjectAndTag(9999, 1));</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Add(System.Object)">
            <summary><para>Converts an object to a CBOR object and adds it to
            the end of this array.</para>
             <para>NOTE: This method can't be used
            to add a tag to an existing CBOR object. To create a CBOR object
            with a given tag, call the <c>CBORObject.FromObjectAndTag</c>
            method and pass the CBOR object and the desired tag number to that
            method.</para>
             </summary>
            <param name='obj'>A CBOR object (or an object convertible to a CBOR
            object) to add to this CBOR array.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.InvalidOperationException'>This instance is not an
            array.</exception>
            <exception cref='T:System.ArgumentException'>The type of <paramref
            name='obj'/> is not supported.</exception>
            <example>
            <para>The following example creates a CBOR array and adds several
            CBOR objects, one of which has a custom CBOR tag, to that array.
            Note the chaining behavior made possible by this method.</para>
            <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(5)
            .Add("text string") .Add(CBORObject.FromObjectAndTag(9999, 1));</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsEInteger">
            <summary>Converts this object to an arbitrary-precision integer.
            Fractional values are truncated to an integer.</summary>
            <returns>The closest arbitrary-precision integer to this
            object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number, including if this object is CBORObject.Null. To
            check the CBOR object for null before conversion, use the following
            idiom (originally written in C# for the.NET version):
            <c>(cbor==null || cbor.IsNull) ? null : cbor.AsEInteger()</c>.</exception>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsBoolean">
            <summary>Returns false if this object is False, Null, or Undefined;
            otherwise, true.</summary>
            <returns>False if this object is False, Null, or Undefined;
            otherwise, true.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsByte">
            <summary>Converts this object to a byte (0 to 255). Floating point
            values are truncated to an integer.</summary>
            <returns>The closest byte-sized integer to this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='T:System.OverflowException'>This object's value exceeds the
            range of a byte (would be less than 0 or greater than 255 when
            truncated to an integer).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsDouble">
            <summary>Converts this object to a 64-bit floating point
            number.</summary>
            <returns>The closest 64-bit floating point number to this object.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsEDecimal">
            <summary>Converts this object to a decimal number.</summary>
            <returns>A decimal number for this object's value. If this object
            is a rational number with a nonterminating decimal expansion,
            returns a decimal number rounded to 34 digits.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number, including if this object is CBORObject.Null. To
            check the CBOR object for null before conversion, use the following
            idiom (originally written in C# for the.NET version):
            <c>(cbor==null || cbor.IsNull) ? null : cbor.AsEDecimal()</c>.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsEFloat">
            <summary>Converts this object to an arbitrary-precision binary
            floating point number.</summary>
            <returns>An arbitrary-precision binary floating-point numbering
            point number for this object's value. Note that if this object is a
            decimal number with a fractional part, the conversion may lose
            information depending on the number. If this object is a rational
            number with a nonterminating binary expansion, returns a binary
            floating-point number rounded to a high but limited
            precision.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number, including if this object is CBORObject.Null. To
            check the CBOR object for null before conversion, use the following
            idiom (originally written in C# for the.NET version):
            <c>(cbor==null || cbor.IsNull) ? null : cbor.AsEFloat()</c>.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsERational">
            <summary>Converts this object to a rational number.</summary>
            <returns>A rational number for this object's value.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number, including if this object is CBORObject.Null. To
            check the CBOR object for null before conversion, use the following
            idiom (originally written in C# for the.NET version):
            <c>(cbor==null || cbor.IsNull) ? null : cbor.AsERational()</c>.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsInt16">
            <summary>Converts this object to a 16-bit signed integer. Floating
            point values are truncated to an integer.</summary>
            <returns>The closest 16-bit signed integer to this
            object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='T:System.OverflowException'>This object's value exceeds the
            range of a 16-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsInt32Value">
            <summary>Converts this object to a 32-bit signed integer if this
            CBOR object's type is Integer. This method disregards the tags this
            object has, if any.</summary>
            <returns>The 32-bit signed integer stored by this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's type is
            not <c>CBORType.Integer</c>
            .</exception>
            <exception cref='T:System.OverflowException'>This object's value exceeds the
            range of a 32-bit signed integer.</exception>
            <example>
            <para>The following example code (originally written in C# for
            the.NET Framework) shows a way to check whether a given CBOR object
            stores a 32-bit signed integer before getting its value.</para>
            <code>CBORObject obj = CBORObject.FromInt32(99999); if (obj.Type ==
            CBORType.Integer &amp;&amp; obj.CanValueFitInInt32()) { /* Not an Int32;
            handle the error */ Console.WriteLine("Not a 32-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt32Value()); }</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsInt64Value">
            <summary>Converts this object to a 64-bit signed integer if this
            CBOR object's type is Integer. This method disregards the tags this
            object has, if any.</summary>
            <returns>The 64-bit signed integer stored by this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's type is
            not <c>CBORType.Integer</c>
            .</exception>
            <exception cref='T:System.OverflowException'>This object's value exceeds the
            range of a 64-bit signed integer.</exception>
            <example>
            <para>The following example code (originally written in C# for
            the.NET Framework) shows a way to check whether a given CBOR object
            stores a 64-bit signed integer before getting its value.</para>
            <code>CBORObject obj = CBORObject.FromInt64(99999);
            if (obj.Type ==
            CBORType.Integer &amp;&amp; obj.CanValueFitInInt64()) {
            &#x2f;&#x2a; Not an Int64; handle the error&#x2a;&#x2f;
            Console.WriteLine("Not a 64-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt64Value()); }</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CanValueFitInInt64">
            <summary>Returns whether this CBOR object stores an integer
            (CBORType.Integer) within the range of a 64-bit signed integer.
            This method disregards the tags this object has, if any.</summary>
            <returns><c>true</c> if this CBOR object stores an integer
            (CBORType.Integer) whose value is at least -(2^63) and less than
            2^63; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CanValueFitInInt32">
            <summary>Returns whether this CBOR object stores an integer
            (CBORType.Integer) within the range of a 32-bit signed integer.
            This method disregards the tags this object has, if any.</summary>
            <returns><c>true</c> if this CBOR object stores an integer
            (CBORType.Integer) whose value is at least -(2^31) and less than
            2^31; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsEIntegerValue">
            <summary>Converts this object to an arbitrary-precision integer if
            this CBOR object's type is Integer. This method disregards the tags
            this object has, if any. (Note that CBOR stores untagged integers
            at least -(2^64) and less than 2^64.).</summary>
            <returns>The integer stored by this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's type is
            not <c>CBORType.Integer</c>.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsDoubleBits">
            <summary>Converts this object to the bits of a 64-bit
            floating-point number if this CBOR object's type is FloatingPoint.
            This method disregards the tags this object has, if any.</summary>
            <returns>The bits of a 64-bit floating-point number stored by this
            object. The most significant bit is the sign (set means negative,
            clear means nonnegative); the next most significant 11 bits are the
            exponent area; and the remaining bits are the mantissa area. If all
            the bits of the exponent area are set and the mantissa area is 0,
            this indicates infinity. If all the bits of the exponent area are
            set and the mantissa area is other than 0, this indicates
            not-a-number (NaN).</returns>
            <exception cref='T:System.InvalidOperationException'>This object's type is
            not <c>CBORType.FloatingPoint</c>.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsDoubleValue">
            <summary>Converts this object to a 64-bit floating-point number if
            this CBOR object's type is FloatingPoint. This method disregards
            the tags this object has, if any.</summary>
            <returns>The 64-bit floating-point number stored by this
            object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's type is
            not <c>CBORType.FloatingPoint</c>.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsNumber">
            <summary>Converts this object to a CBOR number. (NOTE: To determine
            whether this method call can succeed, call the <b>IsNumber</b>
            property (isNumber() method in Java) before calling this
            method.).</summary>
            <returns>The number represented by this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsInt32">
            <summary>Converts this object to a 32-bit signed integer.
            Non-integer number values are truncated to an integer. (NOTE: To
            determine whether this method call can succeed, call the
            <b>CanTruncatedIntFitInInt32</b>
             method before calling this method.
            See the example.).</summary>
            <returns>The closest 32-bit signed integer to this
            object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='T:System.OverflowException'>This object's value exceeds the
            range of a 32-bit signed integer.</exception>
            <example>
            <para>The following example code (originally written in C# for
            the.NET Framework) shows a way to check whether a given CBOR object
            stores a 32-bit signed integer before getting its value.</para>
            <code>CBORObject obj = CBORObject.FromInt32(99999);
            if (obj.IsIntegral &amp;&amp; obj.CanTruncatedIntFitInInt32()) {
            &#x2f;&#x2a; Not an Int32; handle the error &#x2a;&#x2f;
            Console.WriteLine("Not a 32-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt32()); }</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsInt64">
            <summary>Converts this object to a 64-bit signed integer.
            Non-integer numbers are truncated to an integer. (NOTE: To
            determine whether this method call can succeed, call the
            <b>CanTruncatedIntFitInInt64</b>
             method before calling this method.
            See the example.).</summary>
            <returns>The closest 64-bit signed integer to this
            object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='T:System.OverflowException'>This object's value exceeds the
            range of a 64-bit signed integer.</exception>
            <example>
            <para>The following example code (originally written in C# for
            the.NET Framework) shows a way to check whether a given CBOR object
            stores a 64-bit signed integer before getting its value.</para>
            <code>CBORObject obj = CBORObject.FromInt64(99999); if (obj.IsIntegral
            &amp;&amp; obj.CanTruncatedIntFitInInt64()) { &#x2f;&#x2a; Not an Int64; handle&#x2a;&#x2f;
            the error Console.WriteLine("Not a 64-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt64()); }</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsSingle">
            <summary>Converts this object to a 32-bit floating point
            number.</summary>
            <returns>The closest 32-bit floating point number to this object.
            The return value can be positive infinity or negative infinity if
            this object's value exceeds the range of a 32-bit floating point
            number.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.AsString">
            <summary>Gets the value of this object as a text string.</summary>
            <returns>Gets this object's string.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's type is
            not a string, including if this object is CBORObject.Null. To check
            the CBOR object for null before conversion, use the following idiom
            (originally written in C# for the.NET version): <c>(cbor == null ||
            cbor.IsNull) ? null : cbor.AsString()</c>.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CanFitInDouble">
            <summary>Returns whether this object's value can be converted to a
            64-bit floating point number without its value being rounded to
            another numerical value.</summary>
            <returns>Whether this object's value can be converted to a 64-bit
            floating point number without its value being rounded to another
            numerical value. Returns true if this is a not-a-number value, even
            if the value's diagnostic information can' t fit in a 64-bit
            floating point number.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CanFitInInt32">
            <summary>Returns whether this object's numerical value is an
            integer, is -(2^31) or greater, and is less than 2^31.</summary>
            <returns><c>true</c> if this object's numerical value is an
            integer, is -(2^31) or greater, and is less than 2^31; otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CanFitInInt64">
            <summary>Returns whether this object's numerical value is an
            integer, is -(2^63) or greater, and is less than 2^63.</summary>
            <returns><c>true</c> if this object's numerical value is an
            integer, is -(2^63) or greater, and is less than 2^63; otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CanFitInSingle">
            <summary>Returns whether this object's value can be converted to a
            32-bit floating point number without its value being rounded to
            another numerical value.</summary>
            <returns>Whether this object's value can be converted to a 32-bit
            floating point number without its value being rounded to another
            numerical value. Returns true if this is a not-a-number value, even
            if the value's diagnostic information can' t fit in a 32-bit
            floating point number.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt32">
            <summary>Returns whether this object's value, truncated to an
            integer, would be -(2^31) or greater, and less than 2^31.</summary>
            <returns><c>true</c> if this object's value, truncated to an
            integer, would be -(2^31) or greater, and less than 2^31;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt64">
            <summary>Returns whether this object's value, truncated to an
            integer, would be -(2^63) or greater, and less than 2^63.</summary>
            <returns><c>true</c> if this object's value, truncated to an
            integer, would be -(2^63) or greater, and less than 2^63;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CompareTo(PeterO.Cbor.CBORObject)">
            <summary>Compares two CBOR objects. This implementation was changed
            in version 4.0.
            <para>In this implementation:</para>
            <list type=''>
            <item>The null pointer (null reference) is considered less than any
            other object.</item>
            <item>If the two objects are both integers (CBORType.Integer) both
            floating-point values, both byte strings, both simple values
            (including True and False), or both text strings, their CBOR
            encodings (as though EncodeToBytes were called on each integer) are
            compared as though by a byte-by-byte comparison. (This means, for
            example, that positive integers sort before negative
            integers).</item>
            <item>If both objects have a tag, they are compared first by the
            tag's value then by the associated item (which itself can have a
            tag).</item>
            <item>If both objects are arrays, they are compared item by item.
            In this case, if the arrays have different numbers of items, the
            array with more items is treated as greater than the other
            array.</item>
            <item>If both objects are maps, their key-value pairs, sorted by
            key in accordance with this method, are compared, where each pair
            is compared first by key and then by value. In this case, if the
            maps have different numbers of key-value pairs, the map with more
            pairs is treated as greater than the other map.</item>
            <item>If the two objects have different types, the object whose
            type comes first in the order of untagged integers, untagged byte
            strings, untagged text strings, untagged arrays, untagged maps,
            tagged objects, untagged simple values (including True and False)
            and untagged floating point values sorts before the other
            object.</item></list>
            <para>This method is consistent with the Equals
            method.</para></summary>
            <param name='other'>A value to compare with.</param>
            <returns>A negative number, if this value is less than the other
            object; or 0, if both values are equal; or a positive number, if
            this value is less than the other object or if the other object is
            null.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.CompareToIgnoreTags(PeterO.Cbor.CBORObject)">
            <summary>Compares this object and another CBOR object, ignoring the
            tags they have, if any. See the CompareTo method for more
            information on the comparison function.</summary>
            <param name='other'>A value to compare with.</param>
            <returns>Less than 0, if this value is less than the other object;
            or 0, if both values are equal; or greater than 0, if this value is
            less than the other object or if the other object is
            null.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ContainsKey(System.Object)">
            <summary>Determines whether a value of the given key exists in this
            object.</summary>
            <param name='objKey'>The parameter <paramref name='objKey'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if the given key is found, or <c>false</c> if
            the given key is not found or this object is not a map.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ContainsKey(PeterO.Cbor.CBORObject)">
            <summary>Determines whether a value of the given key exists in this
            object.</summary>
            <param name='key'>An object that serves as the key. If this is
            <c>null</c>, checks for <c>CBORObject.Null</c>.</param>
            <returns><c>true</c> if the given key is found, or <c>false</c> if
            the given key is not found or this object is not a map.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ContainsKey(System.String)">
            <summary>Determines whether a value of the given key exists in this
            object.</summary>
            <param name='key'>A string that serves as the key. If this is
            <c>null</c>, checks for <c>CBORObject.Null</c>.</param>
            <returns><c>true</c> if the given key (as a CBOR object) is found,
            or <c>false</c> if the given key is not found or this object is not
            a map.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.EncodeToBytes">
            <summary>
            <para>Writes the binary representation of this CBOR object and
            returns a byte array of that representation. If the CBOR object
            contains CBOR maps, or is a CBOR map itself, the keys to the map
            are written out to the byte array in an undefined order. The
            example code given in
            <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can
            be used to write out certain keys of a CBOR map in a given order.
            For the CTAP2 (FIDO Client-to-Authenticator Protocol 2) canonical
            ordering, which is useful for implementing Web Authentication, call
            <c>EncodeToBytes(new CBOREncodeOptions("ctap2canonical=true"))</c>
            rather than this method.</para></summary>
            <returns>A byte array in CBOR format.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.EncodeToBytes(PeterO.Cbor.CBOREncodeOptions)">
            <summary>Writes the binary representation of this CBOR object and
            returns a byte array of that representation, using the specified
            options for encoding the object to CBOR format. For the CTAP2 (FIDO
            Client-to-Authenticator Protocol 2) canonical ordering, which is
            useful for implementing Web Authentication, call this method as
            follows: <c>EncodeToBytes(new
            CBOREncodeOptions("ctap2canonical=true"))</c>.</summary>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <returns>A byte array in CBOR format.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='options'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Equals(System.Object)">
            <summary>Determines whether this object and another object are
            equal and have the same type. Not-a-number values can be considered
            equal by this method.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Equals(PeterO.Cbor.CBORObject)">
            <summary>Compares the equality of two CBOR objects. Not-a-number
            values can be considered equal by this method.</summary>
            <param name='other'>The object to compare.</param>
            <returns><c>true</c> if the objects are equal; otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.GetByteString">
            <summary>Gets the backing byte array used in this CBOR object, if
            this object is a byte string, without copying the data to a new
            byte array. Any changes in the returned array's contents will be
            reflected in this CBOR object. Note, though, that the array's
            length can't be changed.</summary>
            <returns>The byte array held by this CBOR object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            byte string.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.GetHashCode">
            <summary>Calculates the hash code of this object. The hash code for
            a given instance of this class is not guaranteed to be the same
            across versions of this class, and no application or process IDs
            are used in the hash code calculation.</summary>
            <returns>A 32-bit hash code.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.GetAllTags">
            <summary>Gets a list of all tags, from outermost to
            innermost.</summary>
            <returns>An array of tags, or the empty string if this object is
            untagged.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasOneTag">
            <summary>Returns whether this object has only one tag.</summary>
            <returns><c>true</c> if this object has only one tag; otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasOneTag(System.Int32)">
            <summary>Returns whether this object has only one tag and that tag
            is the given number.</summary>
            <param name='tagValue'>The tag number.</param>
            <returns><c>true</c> if this object has only one tag and that tag
            is the given number; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='tagValue'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasOneTag(PeterO.Numbers.EInteger)">
            <summary>Returns whether this object has only one tag and that tag
            is the given number, expressed as an arbitrary-precision
            integer.</summary>
            <param name='bigTagValue'>An arbitrary-precision integer.</param>
            <returns><c>true</c> if this object has only one tag and that tag
            is the given number; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigTagValue'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='bigTagValue'/> is less than 0.</exception>
        </member>
        <member name="P:PeterO.Cbor.CBORObject.TagCount">
            <summary>Gets the number of tags this object has.</summary>
            <value>The number of tags this object has.</value>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasMostInnerTag(System.Int32)">
            <summary>Returns whether this object has an innermost tag and that
            tag is of the given number.</summary>
            <param name='tagValue'>The tag number.</param>
            <returns><c>true</c> if this object has an innermost tag and that
            tag is of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='tagValue'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasMostInnerTag(PeterO.Numbers.EInteger)">
            <summary>Returns whether this object has an innermost tag and that
            tag is of the given number, expressed as an arbitrary-precision
            number.</summary>
            <param name='bigTagValue'>The tag number.</param>
            <returns><c>true</c> if this object has an innermost tag and that
            tag is of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigTagValue'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='bigTagValue'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasMostOuterTag(System.Int32)">
            <summary>Returns whether this object has an outermost tag and that
            tag is of the given number.</summary>
            <param name='tagValue'>The tag number.</param>
            <returns><c>true</c> if this object has an outermost tag and that
            tag is of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='tagValue'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasMostOuterTag(PeterO.Numbers.EInteger)">
            <summary>Returns whether this object has an outermost tag and that
            tag is of the given number.</summary>
            <param name='bigTagValue'>The tag number.</param>
            <returns><c>true</c> if this object has an outermost tag and that
            tag is of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigTagValue'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='bigTagValue'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasTag(System.Int32)">
            <summary>Returns whether this object has a tag of the given
            number.</summary>
            <param name='tagValue'>The tag value to search for.</param>
            <returns><c>true</c> if this object has a tag of the given number;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='tagValue'/> is less than 0.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='tagValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.HasTag(PeterO.Numbers.EInteger)">
            <summary>Returns whether this object has a tag of the given
            number.</summary>
            <param name='bigTagValue'>The tag value to search for.</param>
            <returns><c>true</c> if this object has a tag of the given number;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigTagValue'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='bigTagValue'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Insert(System.Int32,System.Object)">
            <summary>Inserts an object at the specified position in this CBOR
            array.</summary>
            <param name='index'>Index starting at 0 to insert at.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is not an
            array.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='valueOb'/> has an unsupported type; or <paramref
            name='index'/> is not a valid index into this array.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.IsInfinity">
            <summary>Gets a value indicating whether this CBOR object
            represents infinity.</summary>
            <returns><c>true</c> if this CBOR object represents infinity;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.IsNaN">
            <summary>Gets a value indicating whether this CBOR object
            represents a not-a-number value (as opposed to whether this object
            does not express a number).</summary>
            <returns><c>true</c> if this CBOR object represents a not-a-number
            value (as opposed to whether this object's type is not a number
            type); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.IsNegativeInfinity">
            <summary>Gets a value indicating whether this CBOR object
            represents negative infinity.</summary>
            <returns><c>true</c> if this CBOR object represents negative
            infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.IsPositiveInfinity">
            <summary>Gets a value indicating whether this CBOR object
            represents positive infinity.</summary>
            <returns><c>true</c> if this CBOR object represents positive
            infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Negate">
            <summary>Gets this object's value with the sign reversed.</summary>
            <returns>The reversed-sign form of this number.</returns>
            <exception cref='T:System.InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Clear">
            <summary>Removes all items from this CBOR array or all keys and
            values from this CBOR map.</summary>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            CBOR array or CBOR map.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Remove(System.Object)">
            <summary>If this object is an array, removes the first instance of
            the specified item (once converted to a CBOR object) from the
            array. If this object is a map, removes the item with the given key
            (once converted to a CBOR object) from the map.</summary>
            <param name='obj'>The item or key (once converted to a CBOR object)
            to remove.</param>
            <returns><c>true</c> if the item was removed; otherwise,
            <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='obj'/> is null (as opposed to CBORObject.Null).</exception>
            <exception cref='T:System.InvalidOperationException'>The object is not an
            array or map.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.RemoveAt(System.Int32)">
            <summary>Removes the item at the given index of this CBOR
            array.</summary>
            <param name='index'>The index, starting at 0, of the item to
            remove.</param>
            <returns>Returns "true" if the object was removed. Returns "false"
            if the given index is less than 0, or is at least as high as the
            number of items in the array.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            CBOR array.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Remove(PeterO.Cbor.CBORObject)">
            <summary>If this object is an array, removes the first instance of
            the specified item from the array. If this object is a map, removes
            the item with the given key from the map.</summary>
            <param name='obj'>The item or key to remove.</param>
            <returns><c>true</c> if the item was removed; otherwise,
            <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='obj'/> is null (as opposed to CBORObject.Null).</exception>
            <exception cref='T:System.InvalidOperationException'>The object is not an
            array or map.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Set(System.Object,System.Object)">
            <summary>Maps an object to a key in this CBOR map, or adds the
            value if the key doesn't exist. If this is a CBOR array, instead
            sets the value at the given index to the given value.</summary>
            <param name='key'>If this instance is a CBOR map, this parameter is
            an object representing the key, which will be converted to a
            CBORObject; in this case, this parameter can be null, in which case
            this value is converted to CBORObject.Null. If this instance is a
            CBOR array, this parameter must be a 32-bit signed integer (
            <c>int</c> ) identifying the index (starting from 0) of the item to
            set in the array.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is not a
            map or an array.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='key'/> or <paramref name='valueOb'/> has an unsupported type,
            or this instance is a CBOR array and <paramref name='key'/> is less
            than 0, is the size of this array or greater, or is not a 32-bit
            signed integer ( <c>int</c> ).</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToJSONString">
            <summary>Converts this object to a string in JavaScript Object
            Notation (JSON) format. See the overload to JSONString taking a
            JSONOptions argument for further information.
            <para>If the CBOR object contains CBOR maps, or is a CBOR map
            itself, the keys to the map are written out to the JSON string in
            an undefined order. Map keys other than untagged text strings are
            converted to JSON strings before writing them out (for example,
            <c>22("Test")</c> is converted to <c>"Test"</c> and <c>true</c> is
            converted to <c>"true"</c> ). If, after such conversion, two or
            more map keys are identical, this method throws a CBORException.
            The example code given in
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
            can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</para>
            <para><b>Warning:</b> In general, if this CBOR object contains
            integer map keys or uses other features not supported in JSON, and
            the application converts this CBOR object to JSON and back to CBOR,
            the application
            <i>should not</i> expect the new CBOR object to be exactly the same
            as the original. This is because the conversion in many cases may
            have to convert unsupported features in JSON to supported features
            which correspond to a different feature in CBOR (such as converting
            integer map keys, which are supported in CBOR but not JSON, to text
            strings, which are supported in both).</para></summary>
            <returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)">
            <summary>
             Converts this object to a string in JavaScript Object
            Notation (JSON) format, using the specified options to
            control the encoding process. This function works not
            only with arrays and maps, but also integers, strings,
            byte arrays, and other JSON data types. Notes:
            <list type=''><item>If this object contains maps with non-string
            keys, the keys are converted to JSON strings before writing the map
            as a JSON string.</item>
             <item>If this object represents a number
            (the IsNumber property, or isNumber() method in Java, returns
            true), then it is written out as a number.</item>
             <item>If the CBOR
            object contains CBOR maps, or is a CBOR map itself, the keys to the
            map are written out to the JSON string in an undefined order. Map
            keys other than untagged text strings are converted to JSON strings
            before writing them out (for example, <c>22("Test")</c>
             is
            converted to <c>"Test"</c>
             and <c>true</c>
             is converted to
            <c>"true"</c>
             ). If, after such conversion, two or more map keys
            are identical, this method throws a CBORException.</item>
             <item>If
            a number in the form of an arbitrary-precision binary
            floating-point number has a very high binary exponent, it will be
            converted to a double before being converted to a JSON string. (The
            resulting double could overflow to infinity, in which case the
            arbitrary-precision binary floating-point number is converted to
            null.)</item>
             <item>The string will not begin with a byte-order
            mark (U+FEFF); RFC 8259 (the JSON specification) forbids placing a
            byte-order mark at the beginning of a JSON string.</item>
            <item>Byte strings are converted to Base64 URL without whitespace
            or padding by default (see section 4.1 of RFC 7049). A byte string
            will instead be converted to traditional base64 without whitespace
            and with padding if it has tag 22, or base16 for tag 23. (To create
            a CBOR object with a given tag, call the
            <c>CBORObject.FromObjectAndTag</c>
             method and pass the CBOR object
            and the desired tag number to that method.)</item>
             <item>Rational
            numbers will be converted to their exact form, if possible,
            otherwise to a high-precision approximation. (The resulting
            approximation could overflow to infinity, in which case the
            rational number is converted to null.)</item>
             <item>Simple values
            other than true and false will be converted to null. (This doesn't
            include floating-point numbers.)</item>
             <item>Infinity and
            not-a-number will be converted to null.</item>
             </list>
            <para><b>Warning:</b>
             In general, if this CBOR object contains
            integer map keys or uses other features not supported in JSON, and
            the application converts this CBOR object to JSON and back to CBOR,
            the application <i>should not</i>
             expect the new CBOR object to be
            exactly the same as the original. This is because the conversion in
            many cases may have to convert unsupported features in JSON to
            supported features which correspond to a different feature in CBOR
            (such as converting integer map keys, which are supported in CBOR
            but not JSON, to text strings, which are supported in both).</para>
            <para>The example code given below (originally written in C# for
            the.NET version) can be used to write out certain keys of a CBOR
            map in a given order to a JSON string.</para>
            <code>/* Generates a JSON string of 'mapObj' whose keys are in the order given
            in 'keys' . Only keys found in 'keys' will be written if they exist in
            'mapObj'. */ private static string KeysToJSONMap(CBORObject mapObj,
            IList&lt;CBORObject&gt; keys) { if (mapObj == null) { throw new
            ArgumentNullException)nameof(mapObj));}
            if (keys == null) { throw new
            ArgumentNullException)nameof(keys));}
            if (obj.Type != CBORType.Map) {
            throw new ArgumentException("'obj' is not a map."); } StringBuilder
            builder = new StringBuilder(); var first = true; builder.Append("{");
            for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { if
            (!first) {builder.Append(", ");} var keyString=(key.CBORType ==
            CBORType.String) ? key.AsString() : key.ToJSONString();
            builder.Append(CBORObject.FromObject(keyString) .ToJSONString())
            .Append(":").Append(mapObj[key].ToJSONString()); first=false; } } return
            builder.Append("}").ToString(); }</code>
             .
            </summary>
            <param name='options'>An object containing the options to control
            writing the CBOR object to JSON.</param>
            <returns>A text string containing the converted object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='options'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.ToString">
            <summary>Returns this CBOR object in string form. The format is
            intended to be human-readable, not machine-readable, the format is
            not intended to be parsed, and the format may change at any time.
            The returned string is not necessarily in JavaScript Object
            Notation (JSON); to convert CBOR objects to JSON strings, use the
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
            method instead.</summary>
            <returns>A text representation of this object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.Untag">
            <summary>Gets an object with the same value as this one but without
            the tags it has, if any. If this object is an array, map, or byte
            string, the data will not be copied to the returned object, so
            changes to the returned object will be reflected in this
            one.</summary>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.UntagOne">
            <summary>Gets an object with the same value as this one but without
            this object's outermost tag, if any. If this object is an array,
            map, or byte string, the data will not be copied to the returned
            object, so changes to the returned object will be reflected in this
            one.</summary>
            <returns>A CBORObject object.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream)">
            <summary>Converts this object to a string in JavaScript Object
            Notation (JSON) format, as in the ToJSONString method, and writes
            that string to a data stream in UTF-8. If the CBOR object contains
            CBOR maps, or is a CBOR map, the keys to the map are written out to
            the JSON string in an undefined order. The example code given in
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
            can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
            <example>
            <para>The following example (written in C# for the.NET version)
            shows how to use the <c>LimitedMemoryStream</c>
             class (implemented
            in <i>LimitedMemoryStream.cs</i>
             in the peteroupc/CBOR open-source
            repository) to limit the size of supported JSON serializations of
            CBOR objects.</para>
            <code>
            &#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;
            var maxSize = 20000;
            using (var ms = new LimitedMemoryStream(maxSize)) {
            cborObject.WriteJSONTo(ms);
            var bytes = ms.ToArray();
            }
            </code>
            <para>The following example (written in Java for the Java version)
            shows how to use a subclassed <c>OutputStream</c>
             together with a
            <c>ByteArrayOutputStream</c>
             to limit the size of supported JSON
            serializations of CBOR objects.</para>
            <code>
            &#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;
            final int maxSize = 20000;
            ByteArrayOutputStream ba = new ByteArrayOutputStream();
            &#x2f;&#x2a; throws UnsupportedOperationException if too big&#x2a;&#x2f;
            cborObject.WriteJSONTo(new FilterOutputStream(ba) {
            private int size = 0;
            public void write(byte[] b, int off, int len) throws IOException {
            if (len>(maxSize-size)) {
            throw new UnsupportedOperationException();
            }
            size+=len; out.write(b, off, len);
            }
            public void write(byte b) throws IOException {
            if (size >= maxSize) {
            throw new UnsupportedOperationException();
            }
            size++; out.write(b);
            }
            });
            byte[] bytes = ba.toByteArray();
            </code>
            <para>The following example (written in C# for the.NET version)
            shows how to use a.NET MemoryStream to limit the size of supported
            JSON serializations of CBOR objects. The disadvantage is that the
            extra memory needed to do so can be wasteful, especially if the
            average serialized object is much smaller than the maximum size
            given (for example, if the maximum size is 20000 bytes, but the
            average serialized object has a size of 50 bytes).</para>
            <code>
            var backing = new byte[20000]; &#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;
            byte[] bytes1, bytes2;
            using (var ms = new MemoryStream(backing)) {
            &#x2f;&#x2a; throws NotSupportedException if too big&#x2a;&#x2f;
            cborObject.WriteJSONTo(ms);
            bytes1 = new byte[ms.Position];
            &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;
            System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.Position);
            &#x2f;&#x2a; Reset memory stream&#x2a;&#x2f;
            ms.Position = 0;
            cborObject2.WriteJSONTo(ms);
            bytes2 = new byte[ms.Position];
            &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;
            System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.Position);
            }
            </code>
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream,PeterO.Cbor.JSONOptions)">
            <summary>Converts this object to a string in JavaScript Object
            Notation (JSON) format, as in the ToJSONString method, and writes
            that string to a data stream in UTF-8, using the given JSON options
            to control the encoding process. If the CBOR object contains CBOR
            maps, or is a CBOR map, the keys to the map are written out to the
            JSON string in an undefined order. The example code given in
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
            can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='options'>An object containing the options to control
            writing the CBOR object to JSON.</param>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.FromFloatingPointBits(System.Int64,System.Int32)">
            <summary>Generates a CBOR object from a floating-point number
            represented by its bits.</summary>
            <param name='floatingBits'>The bits of a floating-point number
            number to write.</param>
            <param name='byteCount'>The number of bytes of the stored
            floating-point number; this also specifies the format of the
            "floatingBits" parameter. This value can be 2 if "floatingBits"'s
            lowest (least significant) 16 bits identify the floating-point
            number in IEEE 754r binary16 format; or 4 if "floatingBits"'s
            lowest (least significant) 32 bits identify the floating-point
            number in IEEE 754r binary32 format; or 8 if "floatingBits"
            identifies the floating point number in IEEE 754r binary64 format.
            Any other values for this parameter are invalid.</param>
            <returns>A CBOR object storing the given floating-point
            number.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='byteCount'/> is other than 2, 4, or 8.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteFloatingPointBits(System.IO.Stream,System.Int64,System.Int32)">
            <summary>Writes the bits of a floating-point number in CBOR format
            to a data stream.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='floatingBits'>The bits of a floating-point number
            number to write.</param>
            <param name='byteCount'>The number of bytes of the stored
            floating-point number; this also specifies the format of the
            "floatingBits" parameter. This value can be 2 if "floatingBits"'s
            lowest (least significant) 16 bits identify the floating-point
            number in IEEE 754r binary16 format; or 4 if "floatingBits"'s
            lowest (least significant) 32 bits identify the floating-point
            number in IEEE 754r binary32 format; or 8 if "floatingBits"
            identifies the floating point number in IEEE 754r binary64 format.
            Any other values for this parameter are invalid.</param>
            <returns>The number of 8-bit bytes ordered to be written to the
            data stream.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='byteCount'/> is other than 2, 4, or 8.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteFloatingPointValue(System.IO.Stream,System.Double,System.Int32)">
            <summary>Writes a 64-bit binary floating-point number in CBOR
            format to a data stream, either in its 64-bit form, or its rounded
            32-bit or 16-bit equivalent.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='doubleVal'>The double-precision floating-point number
            to write.</param>
            <param name='byteCount'>The number of 8-bit bytes of the stored
            number. This value can be 2 to store the number in IEEE 754r
            binary16, rounded to nearest, ties to even; or 4 to store the
            number in IEEE 754r binary32, rounded to nearest, ties to even; or
            8 to store the number in IEEE 754r binary64. Any other values for
            this parameter are invalid.</param>
            <returns>The number of 8-bit bytes ordered to be written to the
            data stream.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='byteCount'/> is other than 2, 4, or 8.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteFloatingPointValue(System.IO.Stream,System.Single,System.Int32)">
            <summary>Writes a 32-bit binary floating-point number in CBOR
            format to a data stream, either in its 64- or 32-bit form, or its
            rounded 16-bit equivalent.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='singleVal'>The single-precision floating-point number
            to write.</param>
            <param name='byteCount'>The number of 8-bit bytes of the stored
            number. This value can be 2 to store the number in IEEE 754r
            binary16, rounded to nearest, ties to even; or 4 to store the
            number in IEEE 754r binary32; or 8 to store the number in IEEE 754r
            binary64. Any other values for this parameter are invalid.</param>
            <returns>The number of 8-bit bytes ordered to be written to the
            data stream.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='byteCount'/> is other than 2, 4, or 8.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.Int64)">
            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 64-bit signed integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param>
            <param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='T:System.ArgumentException'>Value is from 24 to 31 and
            major type is 7.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 32-bit signed integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param>
            <param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='T:System.ArgumentException'>Value is from 24 to 31 and
            major type is 7.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> is null.</exception>
            <example>
            <para>In the following example, an array of three objects is
            written as CBOR to a data stream.</para>
            <code>&#x2f;&#x2a; array, length 3&#x2a;&#x2f;
            CBORObject.WriteValue(stream, 4, 3);
            &#x2f;&#x2a; item 1 */
            CBORObject.Write("hello world", stream);
            CBORObject.Write(25, stream); &#x2f;&#x2a; item 2&#x2a;&#x2f;
            CBORObject.Write(false, stream); &#x2f;&#x2a; item 3&#x2a;&#x2f;</code>
            <para>In the following example, a map consisting of two key-value
            pairs is written as CBOR to a data stream.</para>
            <code>CBORObject.WriteValue(stream, 5, 2); &#x2f;&#x2a; map, 2 pairs&#x2a;&#x2f;
            CBORObject.Write("number", stream); &#x2f;&#x2a; key 1 */
            CBORObject.Write(25, stream); &#x2f;&#x2a; value 1 */
            CBORObject.Write("string", stream); &#x2f;&#x2a; key 2&#x2a;&#x2f;
            CBORObject.Write("hello", stream); &#x2f;&#x2a; value 2&#x2a;&#x2f;</code>
            <para>In the following example (originally written in C# for
            the.NET Framework version), a text string is written as CBOR to a
            data stream.</para>
            <code>string str = "hello world"; byte[] bytes =
            DataUtilities.GetUtf8Bytes(str, true); CBORObject.WriteValue(stream, 4,
            bytes.Length); stream.Write(bytes, 0, bytes.Length);</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,PeterO.Numbers.EInteger)">
            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as an arbitrary-precision integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param>
            <param name='bigintValue'>An integer 0 or greater associated with
            the major type, as follows. 0: integer 0 or greater; 1: the
            negative integer's absolute value is 1 plus this number; 2: length
            in bytes of the byte string; 3: length in bytes of the UTF-8 text
            string; 4: number of items in the array; 5: number of key-value
            pairs in the map; 6: tag number; 7: simple value number, which must
            be in the interval [0, 23] or [32, 255]. For major types 0 to 6,
            this number may not be greater than 2^64 - 1.</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='majorType'/> is 7 and value is greater than 255.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='outputStream'/> or <paramref name='bigintValue'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)">
            <summary><para>Writes this CBOR object to a data stream. If the
            CBOR object contains CBOR maps, or is a CBOR map, the keys to the
            map are written out to the data stream in an undefined order. See
            the examples (written in C# for the.NET version) for ways to write
            out certain keys of a CBOR map in a given order. In the case of
            CBOR objects of type FloatingPoint, the number is written using the
            shortest floating-point encoding possible; this is a change from
            previous versions.</para>
             </summary>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <example>
            <para>The following example shows a method that writes each key of
            'mapObj' to 'outputStream', in the order given in 'keys', where
            'mapObj' is written out in the form of a CBOR <b>definite-length
            map</b>
            . Only keys found in 'keys' will be written if they exist
            in 'mapObj'.</para>
            <code>private static void WriteKeysToMap(CBORObject mapObj,
            IList&lt;CBORObject&gt; keys, Stream outputStream) { if (mapObj == null)
            { throw new ArgumentNullException(nameof(mapObj));}
            if (keys == null)
            {throw new ArgumentNullException(nameof(keys));}
            if (outputStream ==
            null) {throw new ArgumentNullException(nameof(outputStream));}
            if
            (obj.Type!=CBORType.Map) { throw new ArgumentException("'obj' is not a
            map."); } int keyCount = 0; for (CBORObject key in keys) { if
            (mapObj.ContainsKey(key)) { keyCount++; } }
            CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in
            keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream);
            mapObj[key].WriteTo(outputStream); } } }</code>
            <para>The following example shows a method that writes each key of
            'mapObj' to 'outputStream', in the order given in 'keys', where
            'mapObj' is written out in the form of a CBOR <b>indefinite-length
            map</b>
            . Only keys found in 'keys' will be written if they exist
            in 'mapObj'.</para>
            <code>private static void WriteKeysToIndefMap(CBORObject mapObj,
            IList&lt;CBORObject&gt; keys, Stream outputStream) { if (mapObj == null)
            { throw new ArgumentNullException(nameof(mapObj));}
            if (keys == null)
            {throw new ArgumentNullException(nameof(keys));}
            if (outputStream ==
            null) {throw new ArgumentNullException(nameof(outputStream));}
            if
            (obj.Type!=CBORType.Map) { throw new ArgumentException("'obj' is not a
            map."); } outputStream.WriteByte((byte)0xBF); for (CBORObject key in
            keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream);
            mapObj[key].WriteTo(outputStream); } }
            outputStream.WriteByte((byte)0xff); }</code>
            <para>The following example shows a method that writes out a list
            of objects to 'outputStream' as an <b>indefinite-length CBOR
            array</b>
            .</para>
            <code>private static void WriteToIndefArray(IList&lt;object&gt; list, Stream
            outputStream) { if (list == null) { throw new
            ArgumentNullException(nameof(list));}
            if (outputStream == null) {throw
            new ArgumentNullException(nameof(outputStream));}
            outputStream.WriteByte((byte)0x9f); for (object item in list) { new
            CBORObject(item).WriteTo(outputStream); }
            outputStream.WriteByte((byte)0xff); }</code>
            <para>The following example (written in C# for the.NET version)
            shows how to use the <c>LimitedMemoryStream</c>
             class (implemented
            in <i>LimitedMemoryStream.cs</i>
             in the peteroupc/CBOR open-source
            repository) to limit the size of supported CBOR
            serializations.</para>
            <code>
            &#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;
            var maxSize = 20000;
            using (var ms = new LimitedMemoryStream(maxSize)) {
            cborObject.WriteTo(ms);
            var bytes = ms.ToArray();
            }
            </code>
            <para>The following example (written in Java for the Java version)
            shows how to use a subclassed <c>OutputStream</c>
             together with a
            <c>ByteArrayOutputStream</c>
             to limit the size of supported CBOR
            serializations.</para>
            <code>
            &#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;
            final int maxSize = 20000;
            ByteArrayOutputStream ba = new ByteArrayOutputStream();
            &#x2f;&#x2a; throws UnsupportedOperationException if too big&#x2a;&#x2f;
            cborObject.WriteTo(new FilterOutputStream(ba) {
            private int size = 0;
            public void write(byte[] b, int off, int len) throws IOException {
            if (len>(maxSize-size)) {
            throw new UnsupportedOperationException();
            }
            size+=len; out.write(b, off, len);
            }
            public void write(byte b) throws IOException {
            if (size >= maxSize) {
            throw new UnsupportedOperationException();
            }
            size++; out.write(b);
            }
            });
            byte[] bytes = ba.toByteArray();
            </code>
            <para>The following example (written in C# for the.NET version)
            shows how to use a.NET MemoryStream to limit the size of supported
            CBOR serializations. The disadvantage is that the extra memory
            needed to do so can be wasteful, especially if the average
            serialized object is much smaller than the maximum size given (for
            example, if the maximum size is 20000 bytes, but the average
            serialized object has a size of 50 bytes).</para>
            <code>
            var backing = new byte[20000]; &#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;
            byte[] bytes1, bytes2;
            using (var ms = new MemoryStream(backing)) {
            &#x2f;&#x2a; throws NotSupportedException if too big&#x2a;&#x2f;
            cborObject.WriteTo(ms);
            bytes1 = new byte[ms.Position];
            &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;
            System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.Position);
            &#x2f;&#x2a; Reset memory stream&#x2a;&#x2f;
            ms.Position = 0;
            cborObject2.WriteTo(ms);
            bytes2 = new byte[ms.Position];
            &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;
            System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.Position);
            }
            </code>
            </example>
        </member>
        <member name="M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
            <summary>Writes this CBOR object to a data stream, using the
            specified options for encoding the data to CBOR format. If the CBOR
            object contains CBOR maps, or is a CBOR map, the keys to the map
            are written out to the data stream in an undefined order. The
            example code given in
            <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can
            be used to write out certain keys of a CBOR map in a given order.
            In the case of CBOR objects of type FloatingPoint, the number is
            written using the shortest floating-point encoding possible; this
            is a change from previous versions.</summary>
            <param name='stream'>A writable data stream.</param>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentException'>Unexpected data
            type".</exception>
        </member>
        <member name="T:PeterO.Cbor.CBORTypeMapper">
            <summary>Holds converters to customize the serialization and
            deserialization behavior of <c>CBORObject.FromObject</c> and
            <c>CBORObject#ToObject</c>, as well as type filters for
            <c>ToObject</c>.</summary>
        </member>
        <member name="M:PeterO.Cbor.CBORTypeMapper.#ctor">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.CBORTypeMapper'/> class.</summary>
        </member>
        <member name="M:PeterO.Cbor.CBORTypeMapper.AddConverter``1(System.Type,PeterO.Cbor.ICBORConverter{``0})">
            <summary>Registers an object that converts objects of a given type
            to CBOR objects (called a CBOR converter).</summary>
            <param name='type'>A Type object specifying the type that the
            converter converts to CBOR objects.</param>
            <param name='converter'>The parameter <paramref name='converter'/>
            is an ICBORConverter object.</param>
            <typeparam name='T'>Must be the same as the "type"
            parameter.</typeparam>
            <returns>This object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='type'/> or <paramref name='converter'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Converter doesn't contain a
            proper ToCBORObject method".</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORTypeMapper.FilterTypeName(System.String)">
            <summary>Returns whether the given Java or.NET type name fits the
            filters given in this mapper.</summary>
            <param name='typeName'>The fully qualified name of a Java or.NET
            class (e.g., <c>java.math.BigInteger</c> or
            <c>System.Globalization.CultureInfo</c> ).</param>
            <returns>Either <c>true</c> if the given Java or.NET type name fits
            the filters given in this mapper, or <c>false</c>
            otherwise.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORTypeMapper.AddTypePrefix(System.String)">
            <summary>Adds a prefix of a Java or.NET type for use in type
            matching. A type matches a prefix if its fully qualified name is or
            begins with that prefix, using codepoint-by-codepoint
            (case-sensitive) matching.</summary>
            <param name='prefix'>The prefix of a Java or.NET type (e.g.,
            `java.math.` or `System.Globalization`).</param>
            <returns>This object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='prefix'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='prefix'/> is empty.</exception>
        </member>
        <member name="M:PeterO.Cbor.CBORTypeMapper.AddTypeName(System.String)">
            <summary>Adds the fully qualified name of a Java or.NET type for
            use in type matching.</summary>
            <param name='name'>The fully qualified name of a Java or.NET class
            (e.g., <c>java.math.BigInteger</c> or
            <c>System.Globalization.CultureInfo</c> ).</param>
            <returns>This object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='name'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='name'/> is empty.</exception>
        </member>
        <member name="T:PeterO.Cbor.PODOptions">
            <summary>Options for converting "plain old data" objects (better
            known as POCOs in .NET or POJOs in Java) to CBOR objects.</summary>
        </member>
        <member name="M:PeterO.Cbor.PODOptions.#ctor">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.PODOptions'/> class.</summary>
        </member>
        <member name="M:PeterO.Cbor.PODOptions.#ctor(System.Boolean,System.Boolean)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.PODOptions'/> class.</summary>
            <param name='removeIsPrefix'>The parameter is not used.</param>
            <param name='useCamelCase'>The value of the "UseCamelCase"
            property.</param>
        </member>
        <member name="M:PeterO.Cbor.PODOptions.#ctor(System.String)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.PODOptions'/> class.</summary>
            <param name='paramString'>A string setting forth the options to
            use. This is a semicolon-separated list of options, each of which
            has a key and a value separated by an equal sign ("="). Whitespace
            and line separators are not allowed to appear between the
            semicolons or between the equal signs, nor may the string begin or
            end with whitespace. The string can be empty, but cannot be null.
            The following is an example of this parameter:
            <c>usecamelcase=true</c>. The key can be any one of the following
            in any combination of case: <c>usecamelcase</c>. Other keys are
            ignored. (Keys are compared using a basic case-insensitive
            comparison, in which two strings are equal if they match after
            converting the basic upper-case letters A to Z (U+0041 to U+005A)
            in both strings to basic lower-case letters.) If two or more
            key/value pairs have equal keys (in a basic case-insensitive
            comparison), the value given for the last such key is used. The key
            just given can have a value of <c>1</c>, <c>true</c>, <c>yes</c>
            , or <c>on</c> (in any combination of case), which means true, and
            any other value meaning false. For example, <c>usecamelcase=Yes</c>
            and <c>usecamelcase=1</c> both set the <c>UseCamelCase</c> property
            to true. In the future, this class may allow other keys to store
            other kinds of values, not just true or false.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='paramString'/> is null.</exception>
        </member>
        <member name="M:PeterO.Cbor.PODOptions.ToString">
            <summary>Gets the values of this options object's properties in
            text form.</summary>
            <returns>A text string containing the values of this options
            object's properties. The format of the string is the same as the
            one described in the String constructor for this class.</returns>
        </member>
        <member name="F:PeterO.Cbor.PODOptions.Default">
            <summary>The default settings for "plain old data"
            options.</summary>
        </member>
        <member name="P:PeterO.Cbor.PODOptions.UseCamelCase">
            <summary>
            <para>Gets a value indicating whether property, field, and method
            names are converted to camel case before they are used as keys.
            This option changes the behavior of key name serialization as
            follows. If "useCamelCase" is <c>false</c> :</para>
            <list>
            <item>In the .NET version, all key names are capitalized, meaning
            the first letter in the name is converted to a basic upper-case
            letter if it's a basic lower-case letter ("a" to "z"). (For
            example, "Name" and "IsName" both remain unchanged.)</item>
            <item>In the Java version, all field names are capitalized, and for
            each eligible method name, the word "get" or "set" is removed from
            the name if the name starts with that word, then the name is
            capitalized. (For example, "getName" and "setName" both become
            "Name", and "isName" becomes "IsName".)</item></list>
            <para>If "useCamelCase" is <c>true</c> :</para>
            <list>
            <item>In the .NET version, for each eligible property or field
            name, the word "Is" is removed from the name if the name starts
            with that word, then the name is converted to camel case, meaning
            the first letter in the name is converted to a basic lower-case
            letter if it's a basic upper-case letter ("A" to "Z"). (For
            example, "Name" and "IsName" both become "name".)</item>
            <item>In the Java version: For each eligible method name, the word
            "get", "set", or "is" is removed from the name if the name starts
            with that word, then the name is converted to camel case. (For
            example, "getName", "setName", and "isName" all become "name".) For
            each eligible field name, the word "is" is removed from the name if
            the name starts with that word, then the name is converted to camel
            case. (For example, "name" and "isName" both become
            "name".)</item></list>
            <para>In the description above, a name "starts with" a word if that
            word begins the name and is followed by a character other than a
            basic digit or basic lower-case letter, that is, other than "a" to
            "z" or "0" to "9".</para></summary>
            <value><c>true</c> If the names are converted to camel case;
            otherwise, <c>false</c>. This property is <c>true</c> by
            default.</value>
        </member>
        <member name="T:PeterO.Cbor.StringRefs">
            <summary>Implements CBOR string references, described at
            <c>http://cbor.schmorp.de/stringref</c>.</summary>
        </member>
        <member name="M:PeterO.Cbor.FastInteger2.Multiply(System.Int32)">
            <summary>Internal API.</summary>
            <param name='val'>The parameter <paramref name='val'/> is an
            internal parameter.</param>
            <returns>A FastInteger2 object.</returns>
        </member>
        <member name="M:PeterO.Cbor.FastInteger2.Subtract(PeterO.Cbor.FastInteger2)">
            <summary>Internal API.</summary>
            <param name='val'>The parameter <paramref name='val'/> is an
            internal parameter.</param>
            <returns>A FastInteger2 object.</returns>
        </member>
        <member name="M:PeterO.Cbor.FastInteger2.SubtractInt(System.Int32)">
            <summary>Internal API.</summary>
            <param name='val'>The parameter <paramref name='val'/> is an
            internal parameter.</param>
            <returns>A FastInteger2 object.</returns>
        </member>
        <member name="T:PeterO.Cbor.CBORException">
            <summary>Exception thrown for errors involving CBOR data.</summary>
        </member>
        <member name="M:PeterO.Cbor.CBORException.#ctor">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.CBORException'/> class.</summary>
        </member>
        <member name="M:PeterO.Cbor.CBORException.#ctor(System.String)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.CBORException'/> class.</summary>
            <param name='message'>The parameter <paramref name='message'/> is a
            text string.</param>
        </member>
        <member name="M:PeterO.Cbor.CBORException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Cbor.CBORException'/> class. Uses the given
            message and inner exception.</summary>
            <param name='message'>The parameter <paramref name='message'/> is a
            text string.</param>
            <param name='innerException'>The parameter <paramref
            name='innerException'/> is an Exception object.</param>
        </member>
        <member name="T:PeterO.Cbor.CBORDataUtilities">
            <summary>Contains methods useful for reading and writing data, with
            a focus on CBOR.</summary>
        </member>
        <member name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String)">
            <summary>Parses a number whose format follows the JSON
            specification. See #ParseJSONNumber(String, integersOnly,
            parseOnly) for more information.</summary>
            <param name='str'>A string to parse. The string is not allowed to
            contain white space characters, including spaces.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0"). Returns null if the parsing fails,
            including if the string is null or empty.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)">
            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259). Roughly speaking, a valid number consists
            of an optional minus sign, one or more basic digits (starting with
            1 to 9 unless the only digit is 0), an optional decimal point (".",
            full stop) with one or more basic digits, and an optional letter E
            or e with an optional plus or minus sign and one or more basic
            digits (the exponent).</summary>
            <param name='str'>A string to parse. The string is not allowed to
            contain white space characters, including spaces.</param>
            <param name='integersOnly'>If true, no decimal points or exponents
            are allowed in the string.</param>
            <param name='positiveOnly'>If true, only positive numbers are
            allowed (the leading minus is disallowed).</param>
            <returns>A CBOR object that represents the parsed number. Returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0"). Returns null if the parsing fails,
            including if the string is null or empty.</returns>
        </member>
        <member name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259). Roughly speaking, a valid number consists
            of an optional minus sign, one or more basic digits (starting with
            1 to 9 unless the only digit is 0), an optional decimal point (".",
            full stop) with one or more basic digits, and an optional letter E
            or e with an optional plus or minus sign and one or more basic
            digits (the exponent).</summary>
            <param name='str'>A string to parse. The string is not allowed to
            contain white space characters, including spaces.</param>
            <param name='integersOnly'>If true, no decimal points or exponents
            are allowed in the string.</param>
            <param name='positiveOnly'>If true, only positive numbers are
            allowed (the leading minus is disallowed).</param>
            <param name='preserveNegativeZero'>If true, returns positive zero
            if the number is a zero that starts with a minus sign (such as "-0"
            or "-0.0"). Otherwise, returns negative zero in this case.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the string is null or
            empty.</returns>
        </member>
        <member name="T:PeterO.DataUtilities">
            <summary>Contains methods useful for reading and writing text
            strings. It is designed to have no dependencies other than the
            basic runtime class library.
            <para>Many of these methods work with text encoded in UTF-8, an
            encoding form of the Unicode Standard which uses one byte to encode
            the most basic characters and two to four bytes to encode other
            characters. For example, the <c>GetUtf8</c> method converts a text
            string to an array of bytes in UTF-8.</para>
            <para>In C# and Java, text strings are represented as sequences of
            16-bit values called <c>char</c> s. These sequences are well-formed
            under UTF-16, a 16-bit encoding form of Unicode, except if they
            contain unpaired surrogate code points. (A surrogate code point is
            used to encode supplementary characters, those with code points
            U+10000 or higher, in UTF-16. A surrogate pair is a high surrogate,
            U+D800 to U+DBFF, followed by a low surrogate, U+DC00 to U+DFFF. An
            unpaired surrogate code point is a surrogate not appearing in a
            surrogate pair.) Many of the methods in this class allow setting
            the behavior to follow when unpaired surrogate code points are
            found in text strings, such as throwing an error or treating the
            unpaired surrogate as a replacement character
            (U+FFFD).</para></summary>
        </member>
        <member name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)">
            <summary>Generates a text string from a UTF-8 byte array.</summary>
            <param name='bytes'>A byte array containing text encoded in
            UTF-8.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>A string represented by the UTF-8 byte array.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The string is not valid UTF-8
            and <paramref name='replace'/> is false.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.CodePointLength(System.String)">
            <summary>Finds the number of Unicode code points in the given text
            string. Unpaired surrogate code points increase this number by 1.
            This is not necessarily the length of the string in "char"
            s.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The number of Unicode code points in the given
            string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>Generates a text string from a portion of a UTF-8 byte
            array.</summary>
            <param name='bytes'>A byte array containing text encoded in
            UTF-8.</param>
            <param name='offset'>Offset into the byte array to start
            reading.</param>
            <param name='bytesCount'>Length, in bytes, of the UTF-8 text
            string.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>A string represented by the UTF-8 byte array.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The portion of the byte array
            is not valid UTF-8 and <paramref name='replace'/> is
            false.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='offset'/> is less than 0, <paramref name='bytesCount'/> is
            less than 0, or offset plus bytesCount is greater than the length
            of "data" .</exception>
        </member>
        <member name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)">
            <summary>
            <para>Encodes a string in UTF-8 as a byte array. This method does
            not insert a byte-order mark (U+FEFF) at the beginning of the
            encoded byte array.</para>
            <para>REMARK: It is not recommended to use
            <c>Encoding.UTF8.GetBytes</c> in.NET, or the <c>getBytes()</c>
            method in Java to do this. For instance, <c>getBytes()</c> encodes
            text strings in a default (so not fixed) character encoding, which
            can be undesirable.</para></summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>The string encoded in UTF-8.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The string contains an unpaired
            surrogate code point and <paramref name='replace'/> is false, or an
            internal error occurred.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)">
            <summary>
            <para>Encodes a string in UTF-8 as a byte array. This method does
            not insert a byte-order mark (U+FEFF) at the beginning of the
            encoded byte array.</para>
            <para>REMARK: It is not recommended to use
            <c>Encoding.UTF8.GetBytes</c> in.NET, or the <c>getBytes()</c>
            method in Java to do this. For instance, <c>getBytes()</c> encodes
            text strings in a default (so not fixed) character encoding, which
            can be undesirable.</para></summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <param name='lenientLineBreaks'>If true, replaces carriage return
            (CR) not followed by line feed (LF) and LF not preceded by CR with
            CR-LF pairs.</param>
            <returns>The string encoded in UTF-8.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The string contains an unpaired
            surrogate code point and <paramref name='replace'/> is false, or an
            internal error occurred.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)">
            <summary>Calculates the number of bytes needed to encode a string
            in UTF-8.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, treats unpaired surrogate code
            points as having 3 UTF-8 bytes (the UTF-8 length of the replacement
            character U+FFFD).</param>
            <returns>The number of bytes needed to encode the given string in
            UTF-8, or -1 if the string contains an unpaired surrogate code
            point and <paramref name='replace'/> is false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)">
            <summary>Gets the Unicode code point just before the given index of
            the string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <returns>The Unicode code point at the previous position. Returns
            -1 if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns the replacement character (U+FFFD) if the
            code point at the previous position is an unpaired surrogate code
            point. If the return value is 65536 (0x10000) or greater, the code
            point takes up two UTF-16 code units.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)">
            <summary>Gets the Unicode code point just before the given index of
            the string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <param name='surrogateBehavior'>Specifies what kind of value to
            return if the previous code point is an unpaired surrogate code
            point: if 0, return the replacement character (U+FFFD); if 1,
            return the value of the surrogate code point; if neither 0 nor 1,
            return -1.</param>
            <returns>The Unicode code point at the previous position. Returns
            -1 if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns a value as specified under <paramref
            name='surrogateBehavior'/> if the code point at the previous
            position is an unpaired surrogate code point. If the return value
            is 65536 (0x10000) or greater, the code point takes up two UTF-16
            code units.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)">
            <summary>Gets the Unicode code point at the given index of the
            string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <returns>The Unicode code point at the given position. Returns -1
            if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns the replacement character (U+FFFD) if the
            code point at that position is an unpaired surrogate code point. If
            the return value is 65536 (0x10000) or greater, the code point
            takes up two UTF-16 code units.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)">
            <summary>Gets the Unicode code point at the given index of the
            string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <param name='surrogateBehavior'>Specifies what kind of value to
            return if the code point at the given index is an unpaired
            surrogate code point: if 0, return the replacement character (U +
            FFFD); if 1, return the value of the surrogate code point; if
            neither 0 nor 1, return -1.</param>
            <returns>The Unicode code point at the given position. Returns -1
            if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns a value as specified under <paramref
            name='surrogateBehavior'/> if the code point at that position is an
            unpaired surrogate code point. If the return value is 65536
            (0x10000) or greater, the code point takes up two UTF-16 code
            units.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <example>
            <para>The following example shows how to iterate a text string code
            point by code point, terminating the loop when an unpaired
            surrogate is found.</para>
            <code>for (var i = 0;i&lt;str.Length; ++i) { int codePoint =
            DataUtilities.CodePointAt(str, i, 2); if (codePoint &lt; 0) { break; /*
            Unpaired surrogate */ } Console.WriteLine("codePoint:"+codePoint); if
            (codePoint &gt;= 0x10000) { i++; /* Supplementary code point */ } }</code>
             .
            </example>
        </member>
        <member name="M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)">
            <summary>Returns a string with the basic upper-case letters A to Z
            (U+0041 to U+005A) converted to the corresponding basic lower-case
            letters. Other characters remain unchanged.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The converted string, or null if <paramref name='str'/> is
            null.</returns>
        </member>
        <member name="M:PeterO.DataUtilities.ToUpperCaseAscii(System.String)">
            <summary>Returns a string with the basic lower-case letters A to Z
            (U+0061 to U+007A) converted to the corresponding basic upper-case
            letters. Other characters remain unchanged.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The converted string, or null if <paramref name='str'/> is
            null.</returns>
        </member>
        <member name="M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)">
            <summary>Compares two strings in Unicode code point order. Unpaired
            surrogate code points are treated as individual code
            points.</summary>
            <param name='strA'>The first string. Can be null.</param>
            <param name='strB'>The second string. Can be null.</param>
            <returns>A value indicating which string is " less" or " greater" .
            0: Both strings are equal or null. Less than 0: a is null and b
            isn't; or the first code point that's different is less in A than
            in B; or b starts with a and is longer than a. Greater than 0: b is
            null and a isn't; or the first code point that's different is
            greater in A than in B; or a starts with b and is longer than
            b.</returns>
        </member>
        <member name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)">
            <summary>Writes a portion of a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='offset'>The Index starting at 0 where the string
            portion to write begins.</param>
            <param name='length'>The length of the string portion to
            write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string portion was written; or -1 if the
            string portion contains an unpaired surrogate code point and
            <paramref name='replace'/> is false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref
            name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>Writes a portion of a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='offset'>The Index starting at 0 where the string
            portion to write begins.</param>
            <param name='length'>The length of the string portion to
            write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <param name='lenientLineBreaks'>If true, replaces carriage return
            (CR) not followed by line feed (LF) and LF not preceded by CR with
            CR-LF pairs.</param>
            <returns>0 if the entire string portion was written; or -1 if the
            string portion contains an unpaired surrogate code point and
            <paramref name='replace'/> is false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='offset'/> is less than 0, <paramref name='length'/> is less
            than 0, or <paramref name='offset'/> plus <paramref name='length'/>
            is greater than the string's length.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)">
            <summary>Writes a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string was written; or -1 if the string
            contains an unpaired surrogate code point and <paramref
            name='replace'/> is false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)">
            <summary>Reads a string in UTF-8 encoding from a byte
            array.</summary>
            <param name='data'>A byte array containing a UTF-8 text
            string.</param>
            <param name='offset'>Offset into the byte array to start
            reading.</param>
            <param name='bytesCount'>Length, in bytes, of the UTF-8 text
            string.</param>
            <param name='builder'>A string builder object where the resulting
            string will be stored.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>0 if the entire string was read without errors, or -1 if
            the string is not valid UTF-8 and <paramref name='replace'/> is
            false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='data'/> is null or <paramref name='builder'/> is
            null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='offset'/> is less than 0, <paramref name='bytesCount'/> is
            less than 0, or offset plus bytesCount is greater than the length
            of <paramref name='data'/>.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)">
            <summary>Reads a string in UTF-8 encoding from a data stream in
            full and returns that string. Replaces invalid encoding with the
            replacement character (U+FFFD).</summary>
            <param name='stream'>A readable data stream.</param>
            <returns>The string read.</returns>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>Reads a string in UTF-8 encoding from a data stream and
            returns that string.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='bytesCount'>The length, in bytes, of the string. If
            this is less than 0, this function will read until the end of the
            stream.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, throws an error if an
            unpaired surrogate code point is seen.</param>
            <returns>The string read.</returns>
            <exception cref='T:System.IO.IOException'>An I/O error occurred; or,
            the string is not valid UTF-8 and <paramref name='replace'/> is
            false.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null.</exception>
        </member>
        <member name="M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)">
            <summary>Reads a string in UTF-8 encoding from a data
            stream.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='bytesCount'>The length, in bytes, of the string. If
            this is less than 0, this function will read until the end of the
            stream.</param>
            <param name='builder'>A string builder object where the resulting
            string will be stored.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when an
            unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string was read without errors, -1 if the
            string is not valid UTF-8 and <paramref name='replace'/> is false,
            or -2 if the end of the stream was reached before the last
            character was read completely (which is only the case if <paramref
            name='bytesCount'/> is 0 or greater).</returns>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='stream'/> is null or <paramref name='builder'/> is
            null.</exception>
        </member>
    </members>
</doc>
